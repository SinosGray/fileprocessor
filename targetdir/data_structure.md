---
categories:
- cs
date: 2019-11-12 18:42:13
tags:
- sup
- sub
- font
- images
- high
title: data_structure
---

# 数据结构

## tips

- int* a=&var;	int* 作为一个整体表示int类型指针

- Typedef 建立一个类型别名的方法很简单，在传统的变量声明表达式里用类型名替代变量名，然后把关键字typedef加在该语句的开头

```cpp
typedef char Line[81];   
```

此时Line类型即代表了具有81个元素的字符数组

<!--more-->

- null用于指针
- fwrite 函数

```c
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
```

​		ptr -- 这是指向要被写入的元素数组的指针。
​		size -- 这是要被写入的每个元素的大小，以字节为单位。
​		nmemb -- 这是元素的个数，每个元素的大小为 size 字节。
​		stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。

- fread 函数

```c
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
```

​		ptr -- 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。
​		size -- 这是要读取的每个元素的大小，以字节为单位。
​		nmemb -- 这是元素的个数，每个元素的大小为 size 字节。
​		stream -- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流

- 注释统一为//or/* */，暂定为写在注释对象上方，用//
- malloc 函数失败返回null
- c++函数内部不能定义函数（但是lamda好像可以）

- fopen

  | 控制读写权限的字符串（必须指明） |                                                              |
  | -------------------------------- | -----------------------------------------------------------: |
  | 打开方式                         |                                                         说明 |
  | "r"                              | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。 |
  | "w"                              | 以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
  | "a"                              | 以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
  | "r+"                             | 以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。 |
  | "w+"                             | 以“写入/更新”方式打开文件，相当于`w`和`r+`叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
  | "a+"                             | 以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
  | 控制读写方式的字符串（可以不写） |                                                              |
  | 打开方式                         |                                                         说明 |
  | "t"                              |                            文本文件。如果不写，默认为`"t"`。 |
  | "b"                              |                                                 二进制文件。 |

  

## 第一章

vscode格式化：option+shift+f

数据项是数据的最小不可分割单位

数据结构是指数据元素的集合以及它们之间的关系

原地工作算法：算法所需要的辅助空间不随着问题的规模而变化，是一个确定的值。

算法分析的主要任务：时间复杂度和空间复杂度

- 数据
- 数据元素：数据的基本单位，可由多个数据项组成。如一本书
- 数据项：是数据的不可分割的最小单位。如书名，作者
- 数据对象：性质相同的数据元素的集合。   如整数，字母
- 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。
  - 包括：集合，线性结构（特点：除了首尾元素，其他元素均只有一个前驱一个后继），树形结构，图状结构或者网状结构
- 逻辑结构：上述结构都是逻辑结构，即表示数据之间的关系
- 存储结构（物理结构）：数据结构在计算机中的表示。
  - 包括：顺序存储结构，链式存储结构
- 数据类型：一个值的集合和定义在这个值上的一组操作的总称，是一个取值范围。可以分为原子类型和结构类型。
- 抽象数据类型：一个数学模型以及定义在该模型上的一组操作，仅取决于一组逻辑特性

![这里写图片描述](https://img-blog.csdn.net/20180129174653374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI2MjMzNjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**算法特性**

1. 输入：一个算法必须有零个或以上输入量。
2. 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。
3. 确定性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际执行结果是确定的。
4. 有穷性：依据图灵的定义，一个演算法是能够被任何[图灵完备](https://zh.wikipedia.org/wiki/图灵完全)系统模拟的一串运算，而[图灵机](https://zh.wikipedia.org/wiki/圖靈機)只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定演算法必须在有限个步骤内完成任务。
5. 可行性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。

**设计要求**

1. 正确性
2. 可读性
3. 健壮性
4. 效率与低存储量要求

[逻辑结构与物理结构](https://www.jianshu.com/p/b36477f4ecee)

## 第二章 线性表

- 线性表存在与否和是否为空时两个概念

  处理方法：头结点；tag标记

  一般约定好null的用法

### 顺序表


### 单链表

- 带或不带表头

- 结构：数据域，指针域

- 生成单链表：先进先出，先进后出；

- 插入节点：节点之后（易）节点之前（难）

- #### 算法

  - 将元素插入有序表：
    - 不带表头：区分四种情况（p后，q前 是否为空）
    - 带表头：q一定不为空
  - 指定位置插入：
    - 计数记到i-1（保证插入当前节点之后
  - 删除元素（记录前驱节点
    - 指定值（两个指针
    - 指定位置（i-1
  - 两个有序单链表合并

- 循环链表

  - 可设尾指针
  - 循环指针指向头结点（如果有的话）

- 双向循环链表

- 结构：prior指针，next指针，data值域

- 1、静态链表是用类似于数组方法实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针。

  - ##### 优点：

    - 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。

  - ##### 缺点：

    - 没有解决连续存储分配(数组)带来的表长难以确定的问题。
    - 失去了顺序存储结构随机存取的特性。

  2、动态链表是用内存申请函数（malloc/new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。

- 顺序表存储密度大，链表小（因为有指针

## 第三章 栈与队列

插入对应的指针有两种方式，一个是最后一个元素，一个是下一个（空）元素

### 栈

- 在表尾插入push删除pop
- 顺序结构：base指针，top指针，stacksize
- 栈顶：尾部，栈底：首部
- LIFO后进先出
- 分类：静态顺序，动态顺序，链式
- 应用：括号匹配，表达式求值
- 链式：栈顶在首节点处

### 队列

- 队首：删除的一段

- 队尾：插入的一段

- FIFO先进先出

- #### 链式队列

  - front，rear两个指针，front：队首
  - 如果删除节点后队列为空，需要修改队尾指针

- #### 顺序结构

  - 顺序循环队列结构：base指针，front，rear下标
  - 假溢出
    - 1. 移动元素？开销大
      2. 循环表√
    - 方案：取模，留出一个单元不用

- 前中后缀表达式

  https://blog.csdn.net/Antineutrino/article/details/6763722

  https://zhuanlan.zhihu.com/p/37467928



## 第五章 数组与广义表

- ### 数组

  - 行序优先，列序优先
  - 数组是一个定长的线性表，所以不能有元素的增加与删除操作✔️

- 特殊矩阵的压缩存储

  - 对称矩阵

    大小：1+2+3+。。。+n

    下三角：aij序号：k=i(i-1)/2 + j

    ​				上三角aij=aji				![截屏2019-12-22下午8.02.26](/Users/akunda/Desktop/hexo/source/images/截屏2019-12-22下午8.02.26.png)

  - 三对角矩阵

    3n-2个元素

    k=(3*(i-1)-1)+(j-i+2)=2i+j-2

- 稀疏矩阵压缩存储

  三元组表

  - 三元组顺序表（不能随机访问）（插入元素可能导致之后的元素依次向后递推）
  - 结构：
    - 节点：行i，列j，值e
    - 节点数组，行数，列数，非零元数，mu，nu，tu

  十字链表

  - 结构

    - 节点：i，j，e，指针：right, down
    - 行头数组，列头数组，mu，nu，tu

  - 当某稀疏矩阵经常进行元素的赋值运算时，十字链表比三元组表更适合作为其存储结构。

    转置矩阵：保证行序优先，需要排序n^2（方便后续计算）

    ​					改进：加两个数组，一个记录转置前每一行有几个元素，一个记录转制后每一行第一个元素在转制后三元组顺序表的位置

  稀疏矩阵的三种不同的存储方法，采用哪种方法要看程序具体要实现的功能：
  如果想完成例如矩阵的转置这样的操作，宜采用三元组顺序表；
  如果想实现矩阵的乘法这样的功能，宜采用行逻辑链接的顺序表；
  如果矩阵运算过程中（例如矩阵的加法），需要不断地插入非 0 元素或删除变为 0 的元素，宜采用十字链表法

  使用三元组顺序表或十字链表作为稀疏矩阵中的物理结构，对元素的访问形式只能是顺序访问

- ### 广义表

  - **广义表**一般记作 LS = (a1, a2, ···, an), n是它的长度，ai可以是单个元素(原子)，也可以是广义表(子表)，当广义表非空时，称第一个元素a1为LS的表头，称其余元素组成的表为LS的表尾。注意：表头是元素(可以是原子，也可以是广表)，表尾一定是广义表。[[1\]](https://zh.wikipedia.org/wiki/广义表#cite_note-1)E=(a, E)是一个递归的表。D=(( ),(e),(a,(b,c,d)))是多层次的广义表，长度为3，深度为3。例：((a),a)的表头是(a)，表尾是(a)，((a))的表头是(a)，表尾是( )。

  - 广义表(((a,b,(),c),d),e,((f),g))的长度是____,深度是____？

    广义表长度是数第一层括号内的逗号数目可以看到,只有一个元素,就是((a,b,(),c),d),e,((f),g)，所以长度是1，深度是数括号数目,深度是4。

  - a1表头，（a2，a3.。。。）表尾

    当广义表的元素是一个数据元素时，称其为原子，否则称为广义表的子表

  - 广义表允许共享子表
  
  - 广义表允许递归定义eg：G=(a,G)
  
  - 链式结构表示
  
    - 原子节点，列表节点（union），tag表示表结点还是原子节点
  
    

## 第六章 树与二叉树

### 定义

- 满二叉树：深度为k，有2<sup>k</sup>-1个节点

- 完全二叉树（顺序二叉树）：深度为k，编号与满二叉树一致，叶子节点只能在倒数两层上，2<sup>k</sup>-1>n>2<sup>k-1</sup>-1，节点i的双亲节点为log <sub>2</sub> i向下取整

  完全二叉树的n<sub>1</sub>=0或1

### 性质

n<sub>0</sub>=n<sub>2</sub>+1 根节点+双节点

n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>

### 存储结构

- 顺序存储：非完全二叉树浪费空间
- 链式存储：二叉，三叉（包括指向双亲节点的指针）

### 遍历

先序，中序，后序

递归算法

中序遍历的非递归算法 栈

<font color=red>后序遍历非递归算法</font>

层序遍历 队列

- 确定二叉树
  - 带空子树的序列可唯一确定二叉树
  - 中序后序两个序列：
    - 根据后序找根节点，在中序划分左右子树，然后重复
  - 先序中序两个序列
    - 根据前序找根节点，在中序划分左右子树，然后重复

- 二叉树深度

### 线索二叉树

- 节点增加标志域ltag rtag，ltag=0代表左链域指示左孩子，ltag=1代表前驱，rtag=0右孩子，rtag=1后继节点
- 原理是将原来的空指针合理利用（2*n-（n-1））
- 线索添加参照遍历序列
- 遍历方法：以中序为例：有后继找后继，无后继找右子孙的最左子孙

### 树的结构

- 双亲表示法/顺序表示法，一个数组存储节点数据和双亲的位置
  - 结构：
    - 节点：data，parent位置下标
    - 节点数组，根的位置r，节点数n
- 孩子表示法/链接表表示法，节点包括数据和孩子的指针（节点数量固定或者非固定）
  - 结构
    - 表结点：child，next指针
    - 数组节点：data，firstchild指针
    - 数组，根位置r，节点数n
- 孩子链表表示法/单链表表示法，有点类似图的邻接表表示法，把弧节点换成孩子节点
- 带双亲的孩子链表表示法，节点包括了双亲结点的位置
- 孩子兄弟表示法/二叉链表，节点：左孩子；节点值；右兄弟，相当于转换成二叉树
  - 结构
    - firchild，nextsibling，data
- 树转化为二叉树：1. 加线：在兄弟之间加线 2. 抹线：把除了左孩子以外其他孩子的线去掉
- 二叉树转换成树：1. 加线：若p是左孩子，则把p的沿分支所有右孩子与p的双亲相连 2. 抹线：抹掉原来二叉树双亲与右孩子的连线
- 森林转化为二叉树：1.每棵树转化为二叉树 2. 根节点相连 3. 以第一棵树的根节点为根节点旋转得到目标二叉树
- 二叉树转化为森林：1.根节点沿右侧所有右孩子连线抹掉，得到多颗二叉树 2.树还原二叉树
- 树的遍历
  - 先根遍历（先序）
    - 访问根节点
    - 访问每一棵子树
  - 后根遍历（相当于转化成二叉树以后的中序遍历）
    - 遍历子树
    - 访问节点
- 森林的遍历
  - 先序遍历
    - 访问根节点
    - 访问每一棵子树
    - 访问其他树
  - 中序遍历
    - 遍历子树
    - 访问节点
    - 访问其他树

### 哈弗曼树（最优二叉树）

- 树的路径长度PL：从root到每一个节点的路径长度之和（完全二叉树最小，单支二叉树最大）
- 树的带权路径长度WPL：每个叶子的权与该叶子的路径长度之和
- 在有n个相同叶子的二叉树中，wpl最小的称为<b>最优二叉树</b>
  - 哈弗曼树的特点
    - 完全二叉树不一定是哈夫曼树
    - 在哈夫曼树中，权值大的节点离根节点比较近
    - 哈弗曼树不唯一，但WPL相同
    - 不存在度为1的节点
  - 哈夫曼算法（构造哈夫曼树）
    - 选两个根节点权值最小的叶子作为左右子树构成一棵新的二叉树，根节点权值为左右子树权值之和
    - 重复上述过程
  - 哈夫曼编码（最小冗余码）
    - 统计出现频率，作为叶子节点权值，构造哈弗曼树
    - 左分支标0，右分支标1，形成二进制串
    - 特点：任一编码不是其他编码的前缀
    - 编码从叶子到根，译码从根到叶子

31

二叉树的先序遍历序列和后序遍历序列正好相反：高度等于其节点数https://zhidao.baidu.com/question/746019821869617732.html

## 第七章 图

### 概念

- 连通图：任意两个顶点都有路径
- 连通分量（极大连通图）
- 生成树（极小连通图）

### 存储结构

1. 数组表示法：一个一维，一个二维，可以加权值

   <img src="/images/截屏2019-12-03下午2.35.09.png" alt="截屏2019-12-03下午2.35.09" style="zoom:50%;" />

2. 邻接表表示法

   邻接表，逆邻接表（出入度）

   <img src="/images/截屏2019-12-03下午2.39.20.png" alt="截屏2019-12-03下午2.39.20" style="zoom:50%;" />

3. 十字链表表示法（有向图）

   <img src="/Users/akunda/Desktop/hexo/source/images/截屏2019-12-03下午2.41.12.png" alt="截屏2019-12-03下午2.41.12" style="zoom:50%;" />

4. 邻接多重表（无向图）

   每条弧节点包括：标志域（是否被搜索过），该边依附的两个顶点在顶点数组里的位置，指向下一条依附于两个顶点的边的指针
   
   <img src="/images/截屏2019-12-03下午2.42.43.png" alt="截屏2019-12-03下午2.42.43" style="zoom:50%;" />

### 图的遍历

1. 深度优先遍历

   递归，堆栈

   <img src="/images/截屏2019-12-03下午6.25.27.png" alt="截屏2019-12-03下午6.25.27" style="zoom:50%;" />

2. 广度优先遍历

  <img src="/images/截屏2019-12-03下午6.30.30.png" alt="截屏2019-12-03下午6.30.30" style="zoom:50%;" />

### 图的连通性

- 连通分量

- 生成树，dfs，bfs生成树

- 有向图强连通图，顺着一遍，逆着一遍，取交集

- 网的最小生成树

  mst性质

  - prim算法	分成u，v-u，把点依次纳入u中<img src="/images/截屏2019-12-10下午8.25.48.png" alt="截屏2019-12-10下午8.25.48" style="zoom:50%;" />
  - kruskai算法：把边按照从小到大依次加入，保证不形成回路

### 有向无环图（DAG图）

- AOV图
  
- 拓扑排序（不能有回路DAG）先输出没有入度的
  - 顶点表示活动，弧表示约束关系
  - 拓扑排序产生计划
  
- AOE网
  
  - 顶点表示事件，弧表示活动，权表示活动时间
  
  - 只有一个源点和汇点
  
  - 关键路径（最长路径）包括的活动叫关键活动
  
  - 活动最早开始时间e（最长路径，max{前一个活动+弧长}），最晚开始时间l，活动余量l-e，关键活动l-e=0
  
    最早发生时间顺推max最迟逆推min
  
  - 按拓扑排序计算

### 最短路径

- dijkstra路径长度递增法 O(n<sup>2</sup>) 类似prim算法
- floyd算法O(n<sup>3</sup>)

## 第九章 查找

静态查找表，动态查找表（可以增加删除）

ASL平均查找长度

动态查找表：表结构在查找过程中动态生成。eg二叉排序树，哈希表

### 顺序表查找（数组）

哨兵技术：（消除越界判定的开销）把给定查找的元素放在第一个，然后从最后一个开始往前查找，从而保证不会越界

ASL=(n+1)/2

O(n)

### 折半查找法

有序顺序表（递增）

low mid high

- 判定low<=high

  mid=[(low+high)/2]

  左边查找：low不变，high=mid-1

  右边查找：high不变，low=mid+1

判定树：描述折半查找过程的二叉树，对于某一个节点N，从根节点到N的路径上包含的所有节点，实际上对应于在查找节点N时查找过的所有元素，查找次数=树的层数

O(log(n))

asl=1*1+2\*2+3\*4+4\*8+5\*...

### 分块查找法

分成很多块，块与块之间有序，块内无序；于是先折半查找，再顺序查找；需要借助索引表（包括每一个块的起始位置和最大值）

 ASL'blk=(b+1)/2+(s+1)/2=(s2+2s+n)/(2s)

s=√n效率最高

### 二叉排序树查找法

- 二叉排序树T：

  - T左子树所有节点值小于T根节点的值

    T右子树所有节点值大于T根节点的值

    T左右子树均为二叉排序树

  对二叉排序树进行中序遍历，输出为递增序列

- 向二叉排序树插入数据

  相当于在查找失败时插入

- 向二叉排序树删除数据

  根据删除节点的子树情况分四种讨论（这里删除的节点是双亲节点的左子树）

  - 左空右空：直接删除

  - 左空右不空：将右子树接到双亲结点的左子树上

  - 左不空右空：将左子树接到双亲结点的左子树上

  - <font color=red>左不空右不空</font>：

    P为删除节点，F为双亲结点，S为P最右边的没有右子树的节点

    - 法1 P的左子树接到F左，P右子树接到S右
    - 法2 S代替P，S左子树代替原来的S

- 平衡二叉树T（AVL树）：

  T左右子树深度只差不超过1

  T左右子树均为平衡二叉树

- 创建平衡二叉树

  依次插入元素，如果不平衡了，对最小不平衡子树进行平衡化处理

  - 最小不平衡二叉树：以距离新插入节点最近的，平衡因子>1的节点为根的子树

  根据市区平衡的插入位置分类

  - LL：单向右旋，右旋右靠 ![这里写图片描述](http://img.blog.csdn.net/20170713212023464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnl1eGluZ3h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
  - RR：单向左旋![这里写图片描述](http://img.blog.csdn.net/20170713213413602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnl1eGluZ3h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
  - LR：左旋右旋![这里写图片描述](http://img.blog.csdn.net/20170713215031006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnl1eGluZ3h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
  - RL：右旋左旋![这里写图片描述](http://img.blog.csdn.net/20170713214216909?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbnl1eGluZ3h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

  LL , LR ，RR ，RL其实已经为我们提供了最后哪个结点作为新的根指明了方向。如 LR 型最后的根结点为原来的根的左孩子的右孩子，RL 型最后的根结点为原来的根的右孩子的左孩子。只要记住这四种情况，可以很快地推导出所有的情况。

  https://zhuanlan.zhihu.com/p/56066942

  O(log(n))

### 哈希查找法（散列）

- 哈希函数H(key)将key与在哈希表L中的存储位置对应起来

- 影响散列查找时间效率的主要因素：与散列表长和散列表中实际元素个数均相关asl=元素个数/哈希表长

- 构造哈希函数：

  基本原则：均匀，避免冲突情况的过度集中，预期哈希查找的时间效率能达到最佳

  常见方法：

  - 直接定址法

    H(key)=a*key+b

  - 数字分析法

    事先分析关键字的每一位，从中选取若干随机位构成哈希地址

  - 平方取中法

    取关键字平方后中间若干位作为哈希地址

  - 折叠法

    将关键字分成位数相同的若干个段，将各段求和作为哈希地址

  - 余数法

    H(key)=key mod p (p<=m) m为哈希表长，p为质数，或不含小于20质因数的合数

- 解决冲突的方法

  - 开放地址法

    在H(key)为起点，取一个增量di作为下一个探测的位置

    即H<sub>i</sub>(key)=(H(key)+di) mod m   m为哈希表长

    di取法

    - 线性探测，di取1，2，3……m-1
    - 二次探测，di=1<sup>2</sup>，-1<sup>2</sup>，2<sup>2</sup>，-2<sup>2</sup>……+-k<sup>2</sup>   (k<=m/2)
    - 伪随机探测

  - 再哈希法

    使用其他哈希函数RH计算关键字key的下一个地址直到不再发生冲突

  - 链地址法

    将关键字的同义词存储在各自的单链表中

  - 公共溢出区法

    当遇到冲突时，统一将所有同义词存储到“公共溢出区”

哈希的装填因子a=n/m n为关键字数，m为表长

## 第十章 内部排序（在内存中排序）

### 插入排序

#### 直接插入排序

不断插入新的元素使之有序，要确定位置，移动后面元素的位置

不断将要插入的元素放到一个额外存储空间内，使得这个元素的位置空出来，从后往前比较

- 最好：正序：比较n-1次，移动0次

- 最坏：逆序：比较（2+3+4+n）移动（2+1）+（3+1）+++（n+1）

- 分类

  - 折半插入排序

    顺序查找定位变为折半查找定位，比较次数变成nlogn，移动次数不变

  - 2-路插入排序

    需要辅助数组n

    首尾视为循环，比较次数不变，平均移动次数减半

  - 表插入排序

    运用循环静态链表，不断修改指针域

  - 希尔排序

    不停分隔子序列，序列内部直接插入排序，最后整个排序

    记第i步序列分成的组数为di，总趟数为m，则

    - dm=1
    - i<j, di>dj
    - i<j, i!=j, di,dj最大公约数为1

### 交换排序

#### 冒泡排序

走一趟就确定最后的一个元素

#### 快速排序

思想：low high，把low放到合适位置，并把以low划分为两个子表

low<high时

​	向左移动high，将首次遇到的小于L[low]的L[high]与L[low]交换

​	向右移动low，将首次遇到的大于L[high]的L[low]与L[high]交换

形成了一棵二叉树，O(n)-O(logn)

辅助空间log(n)（递归啊）

### 选择排序

选择最大元素与最后一个元素交换

#### 简单选择排序

顺序查找确定最大元素

#### 堆排序

- 堆（大顶堆）：构建完全二叉树

  a<sub>i</sub>>=a<sub>2i</sub>, a<sub>i</sub>>=a<sub>2i+1</sub>

- 调整堆：树的左右子树都为堆，但是仅根不满足堆的条件，将其转化为堆

  - 思想：将树根与左右子树的最大值交换，重复上述步骤，直到为堆

- 创建堆：从最大序号的非叶子节点开始逐步到根进行调整堆，时间复杂度n

- 堆排序算法：将L转化为大顶堆，将堆的根与最后一个叶子（L最后一个元素）交换，然后除最后一个叶子重复上述步骤，最后层序遍历得到递增序列

- T<O(nlogn)，空间复杂度O(1)

  

### 归并排序

- 思想：先把L（n）看做有n个子表，然后相邻表合并，重复
- 分析：可以用二叉树表示，T<O(nlogn), S=O(n)

### 基数排序法

- 多关键字排序
  - MSD最主位优先排序，从前往后，需要分割序列
  - LSD最次位优先排序，从后往前，不需要分割，而且只能用稳定排序算法
- 基数排序：将每一个位视作一单关键字，采用LSD排序（桶，队列）
  - 思想：入桶,出桶重复多边
  - T=2nd, S=基数*元素个数



- 稳定排序：冒泡排序，插入排序，归并排序，基数排序，希尔排序

- 不稳定排序：选择排序，快速排序，堆排序

- https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html

- | 排序方法 | 最好情况                 | 平均时间   | 最坏情况                                  | 辅助存储 | 稳定性  |
  | -------- | ------------------------ | ---------- | ----------------------------------------- | -------- | ------- |
  | 简单排序 | O(n)                     | O(n2)      | O(n2)                                     | O(1)     | 稳定*   |
  | 快速排序 | O(nlgn )                 | O(nlgn)    | O(n2)有序，变成冒泡排序                   | O(lgn)   | 不稳定  |
  | 堆排序   | O(nlgn )                 | O(nlgn )   | O(nlgn)                                   | O(1)     | 不稳定  |
  | 归并排序 | O(nlgn )                 | O(nlgn )   | O(nlgn)                                   | O(n) n   | 稳定    |
  | 基数排序 | O(d(n+rd))               | O(d(n+rd)) | O(d(n+rd))                                | O(rd)    | 稳定    |
  |          |                          |            |                                           |          |         |
  | 简单选择 | O(n2)                    | O(n2)      | O(n2)                                     | O(1)     | 不稳定* |
  | 直接插入 | O(n)正序，比较n-1，移动0 | O(n2)      | O(n2)逆序，比较i2->n求和，移动i3->n+1求和 | O(1)哨兵 | 稳定    |
  | 折半插入 | O(nlgn )                 | O(nlgn )   | O(nlgn)                                   | O(1)     | 稳定    |
  
- 有序表的合并

  最好min{m,n}最坏n+m-1













