---
categories:
- 私密
password: wzqdiary
sticky: 0
tags:
- leetcode
- res
- offer
- int
- problems
title: 面经
---

> 

<!--more-->

# 自我介绍

面试官您好, 我叫魏子清, 本科就读于华中科技大学计算机科学与技术专业, 是一名大四应届毕业生

本科阶段在华科启明学院 Dian 团队进行项目开发, 团队编号 691, 下面我简单介绍一下我所参与的两个项目

\1. 熟悉常用的算法和数据结构；

\2. 熟悉网络编程，熟悉 TCP/IP 通信原理，熟悉 HTTP 等常用协议；

\3. 熟悉 C/C++，良好的编码风格；

\4. 掌握 python 等脚本使用；

\5. 掌握 Qt 基本组件使用；

\6. 能书写规范工作文档；

对数据敏感，执行力较强，有与甲方沟通协商的经历，擅长组内协调和项目推动；



其他项目：基于 Qt 的 socket 编程，基于 http 通信的选课系统、串口调试器等。



**深信服科技股份有限公司 SIEM 日志接入**( Security Information Event Management，安全信息与事件管理)

1. 在虚拟机上配置软件环境, 调整软件行为使其尽可能的产生各种种类的日志
2. 通过 logstash 将生成的日志输出为 json 格式
3. 测试解析的速度, 输出日志解析文档

sendmail, mysql, informix, websphere

自己写脚本





**武汉烽火凯卓科技有限公司 基于海康流媒体的边防监控系统客户端**

这款产品已经成功落地, 在边境派出所投入使用

这个项目在我们接手时 完成度比较高, 几经转手, 甲方添加新功能 丰富完善

- 在 alarm 时弹出监控截图的窗口, eventdata

- 录像回放剪辑, 录像下载, 传时间 基准时间
- 录像回放节点过滤
- 预览界面左边是摄像头通道树, 右边是九宫格预览, 
  树本身, 树和预览界面之间, 拖拽, 双击, 一组摄像头拖拽
- 抓图, 三连抓, 全景拼接
- 收藏夹, 服务端沟通, 闪退



在预览界面将设备节点再不同区域来回拖动会导致闪退问题

1. 首先通过依次关闭各个软件模块, 定位到问题是出现在预览模块中
2. 版本回退, 收藏夹
3. 之后通过调试捕捉到闪退是报出的 std::non_rtti_object 异常, 分析后判断这是因为对一个已经释放的野指针执行 dynamic_cast 导致的(Run-Time Type Identification)
4. 通过在树的继承间打印内存信息，对数据进行分析，发现是由于收藏夹树刷新时没有清理指针的缓存，通过对树的重构解决







这个项目是分很多模块的, 根据 config 文件来决定哪些模块需要加载, 然后每个模块都会继承一个 icomponent 接口, 这些模块的指针保存在一个指针数组里, 外界可以通过响应的名字来进行调用.

# 动态规划

　　我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。

　　这就是DP（动态规划，dynamic programming）.

　　将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。

## fib

fib(n) = fib(n-1) + fib(n-2)

- classic

  ```cpp
  int fib(int n){
    if (n<=2) return 1;
    return fib(n-1) + fib(n-2);
  }
  ```

- memoization

  ```cpp
  vector<int> memo(50, -1);
  int fib(int n)
  {
      if(n <= 1){
          return 1;
      }
      if(memo[n] != -1)
          return memo[n];
      memo[n] = fib(n-1) + fib(n-2);
      return memo[n];
  }
  ```

## grid travel

gridtravel(x, y) = gridtravel(x-1, y) + gridtravel(x, y-1)

- classical

  ```cpp
  int gridtravel(m, n){
    if(m==1 && n==1)
      return 1;
    if(m==0 || n==0)
      return 0;
    return gridtravel(m-1, n) + gridtravel(m, n-1);
  }
  ```

- memoization

  ```cpp
  unordered_map<string, long long> memo;
  
  long long gridtravel(int m, int n){
      string key = to_string(m) + "|" + to_string(n);
      if(memo.find(key) == memo.end()){
          if(m==1 && n==1)
              memo[key] = 1;
          else if(m==0 || n==0)
              memo[key] = 0;
          else
              memo[key] = gridtravel(m-1, n) + gridtravel(m, n-1);
      }
      return memo[key];
  }
  //可优化: 4,3 == 3, 4
  ```

# 反转链表

## 递归

```cpp
class Solution{
  public ListNode* reverseList(ListNode* head){
    if(head == null || head->next == null)
      return head;
    ListNode* newhead = reverseList(head->next);
    head->next->next = head;
    head->next = null;
    return newhead;
  }
};
```

## 迭代

```cpp
class Solution
{
  public ListNode* reverseList(ListNode* head)
  {
    ListNode* prev = nullptr;
    ListNode* cur = head;
    
    while(cur)
    {
      ListNode* next = cur->next;
      cur->next = prev;
      prev = cur;
      cur = next;
    }
    return prev;
  }
};
```

# 全排列

```cpp
class Solution {
public:
    void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){
        // 所有数都填完了
        if (first == len) {
            res.push_back(output);
            return;
        }
        for (int i = first; i < len; ++i) {
            // 动态维护数组
            swap(output[i], output[first]);
            // 继续递归填下一个数
            backtrack(res, output, first + 1, len);
            // 撤销操作
            swap(output[i], output[first]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int> > res;
        backtrack(res, nums, 0, (int)nums.size());
        return res;
    }
};
```

# 哈希表

链接：https://www.zhihu.com/question/26762707/answer/890181997

> 提到hash，相信大多数同学都不会陌生，之前很火现在也依旧很火的技术区块链背后的底层原理之一就是hash，下面就从hash算法的原理和实际应用等几个角度，对[hash算法](https://www.zhihu.com/search?q=hash算法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})进行一个讲解。

## **1、什么是Hash**

Hash也称散列、哈希，对应的英文都是Hash。**基本原理就是把任意长度的输入，通过[Hash算法](https://www.zhihu.com/search?q=Hash算法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})变成固定长度的输出**。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。

```text
echo md5("这是一个测试文案");
// 输出结果：2124968af757ed51e71e6abeac04f98d
```

在这个例子里，`这是一个测试文案`是原始值，`2124968af757ed51e71e6abeac04f98d` 就是经过hash算法得到的Hash值。整个Hash算法的过程就是把原始任意长度的值空间，映射成固定长度的值空间的过程。

## **2、Hash的特点**

一个优秀的hash算法，需要什么样的要求呢？

- a)、从hash值不可以反向推导出原始的数据
  这个从上面MD5的例子里可以明确看到，经过映射后的数据和原始数据没有对应关系

- b)、输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值
  echo md5("这是一个测试文案");
  // 输出结果：2124968af757ed51e71e6abeac04f98d
  echo md5("这是二个测试文案");
  // 输出结果：bcc2a4bb4373076d494b2223aef9f702

  可以看到我们只改了一个文字，但是整个得到的hash值产生了非常大的变化。

- c)、[哈希算法](https://www.zhihu.com/search?q=哈希算法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})的执行效率要高效，长的文本也能快速地计算出哈希值

- d)、hash算法的冲突概率要小
  由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。那么作为一个好的hash算法，就需要这种冲突的概率尽可能小。

> 桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的“抽屉原理”。

## **3、Hash碰撞的解决方案**

前面提到了hash算法是一定会有冲突的，那么如果我们如果遇到了hash冲突需要解决的时候应该怎么处理呢？比较常用的算法是`链地址法`和`开放地址法`。

### **3.1 链地址法**

链表地址法是使用一个**[链表数组](https://www.zhihu.com/search?q=链表数组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})**，来存储相应数据，当hash遇到冲突的时候依次添加到链表的后面进行处理。

![img](https://pic1.zhimg.com/50/v2-976fe3afe0d50dbafa97ae47f6f6a53b_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-976fe3afe0d50dbafa97ae47f6f6a53b_1440w.webp?source=1940ef5c)

链地址在处理的流程如下：
添加一个元素的时候，首先计算元素key的hash值，确定插入数组中的位置。如果当前位置下没有重复数据，则直接添加到当前位置。当遇到冲突的时候，添加到同一个hash值的元素后面，行成一个链表。这个链表的特点是同一个链表上的Hash值相同。java的数据结构HashMap使用的就是这种方法来处理冲突，JDK1.8中，针对链表上的数据超过8条的时候，使用了红黑树进行优化。由于篇幅原因，这里不深入讨论相关数据结构，有兴趣的同学可以参考这篇文章：

[《Java集合之一—HashMap》](https://link.zhihu.com/?target=https%3A//blog.csdn.net/woshimaxiao1/article/details/83661464)

### **3.2 开放地址法**

开放地址法是指大小为 M 的数组保存 N 个键值对，其中 M > N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为“开放地址”哈希表。[线性探测法](https://www.zhihu.com/search?q=线性探测法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})，就是比较常用的一种“开放地址”哈希表的一种实现方式。线性探测法的核心思想是当冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。简单来说就是：**一旦发生冲突，就去寻找下 一个空的散列表地址，只要散列表足够大，空的散列地址总能找到。**

线性探测法的数学描述是：**h(k, i) = (h(k, 0) + i) mod m**，i表示当前进行的是第几轮探查。i=1时，即是探查h(k, 0)的下一个；i=2，即是再下一个。这个方法是简单地向下探查。[mod m](https://www.zhihu.com/search?q=mod+m&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})表示：到达了表的底下之后，回到顶端从头开始。

对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。但是不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用`装载因子`（load factor）来表示空位的多少。

**散列表的装载因子=填入表中的元素个数/散列表的长度**。装载因子越大，说明冲突越多，性能越差。

### **3.3 两种方案的demo示例**

假设散列长为8，散列函数H(K)=K mod 7，给定的关键字序列为{32,14,23,2, 20}
当使用链表法时，相应的数据结构如下图所示：

![img](https://pica.zhimg.com/50/v2-dabac86f74bb61605f93258a01917590_720w.jpg?source=1940ef5c)

当使用线性探测法时，相应的数据结果如下图所示：

![img](https://picx.zhimg.com/50/v2-cf46c1e0d22be22882ebc1974ae3c2cf_720w.jpg?source=1940ef5c)

这里的两种算法的区别是2这个元素，在链表法中还是在节点2的位置上，但是在线性探测法遇到冲突时会将冲突数据放到下一个空的位置下面。

## **4、hash算法在日常活动中的应用**

### **4.1 信息加密**

首先我们看一下信息加密的应用。2011年CSDN脱库事件，导致超过600W的用户的密码泄露，让人失望的是，CSDN是明文存储用户的注册邮箱和密码的。作为用户的非常隐私的信息，最简单的保护措施就是对密码进行hash加密。在客户端对用户输入的密码进行hash运算，然后**在服务端的数据库中保存用户密码的hash值。由于服务器端也没有存储密码的明文，所以目前很多网站也就不再有找回密码的功能了。**

- 这里也友情提示一下大家：如果在使用中发现某网站还有提供找回密码的功能，就要好好担心下这个网站的安全性了。

看到这里有些同学会觉得那么我们是不是对用户输入的密码进行一次MD5加密就可以了呢，这样就算恶意用户知道了hash值，也没有办法拿到用户的真实密码。假设用户的密码是`123456789`，经过一次md5以后得到的值是:

```
25f9e794323b453885f5181f1b624d0b
```

那么是不是使用了这个加密后的字符串来存密码就万无一失了呢，理想总是很丰满，而现实总是很骨感的。

大家可以看一下这个网站：

[https://www.cmd5.com/](https://link.zhihu.com/?target=https%3A//www.cmd5.com/)

这里是该网站的相关介绍：

> 本站针对md5、sha1等全球通用公开的加密算法进行反向查询，通过穷举字符组合的方式，创建了明文密文对应查询数据库，创建的记录约90万亿条，占用硬盘超过500TB，查询成功率95%以上，很多复杂密文只有本站才可查询。已稳定运行十余年，国内外享有盛誉

![img](https://pic1.zhimg.com/50/v2-0254fb3b64eefecac297c6c6b4c1fb15_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-0254fb3b64eefecac297c6c6b4c1fb15_1440w.webp?source=1940ef5c)

那么一般针对这种问题，我们的解决之道就是**引入salt(加盐)，**即利用特殊字符（盐）和用户的输入合在一起组成新的字符串进行加密。

针对salt泄露的问题，其实还有一种解决办法，即使用HMAC进行加密（Hash-based Message Authentication Code）。这种算法的核心思路是加密使用的key是从服务器端获取的，每一个用户的是不一样的。如果发生了泄露，那么也就是这一个用户的会被泄露，不会影响到全局。

这里也留给大家一个思考点，如果恶意用户直接抓取了你的活动参与链接，也就是拿到了你计算后的hash值，那从技术的角度上说，我们还有没有其他可以提升恶意用户的违法成本呢？



### **4.2 数据校验**

\- **git commit id**
使用过git的同学都应该清楚，每次git提交后都有一个commit id，比如`:`

```
19d02d2cc358e59b3d04f82677dbf3808ae4fc40
```

就是一次git commit的结果，那么这个id是如何生成出来的呢？查阅了相关资料，使用如下代码可以进行查看：

```text
printf "commit %s\0" $(git cat-file commit HEAD | wc -c); git cat-file commit HEAD
```

git的commit id主要包括了以下几部分内容：Tree 哈希，parent哈希、作者信息和本次提交的备注。

![img](https://picx.zhimg.com/50/v2-3b5d910a510a359c0a0c69cb135b4996_720w.jpg?source=1940ef5c)![img](https://picx.zhimg.com/80/v2-3b5d910a510a359c0a0c69cb135b4996_1440w.webp?source=1940ef5c)

针对这些信息进行SHA-1 算法后得到值就是本次提交的commit id。简单来讲，就是对于单次提交的头信息的一个校验和。

> Linux kernel开创者和Git的开发者——Linus说，Git使用了sha1并非是为了安全性，而是为了数据的完整性；它可以保证，在很多年后，你重新checkout某个commit时，一定是它多年前的当时的状态，完全一摸一样，完全值得信任。

但最新研究表明，理论上对其进行[哈希碰撞](https://www.zhihu.com/search?q=哈希碰撞&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})（hash collision，不同的两块数据有相同的hash值）的攻击可以在2^51（2的51次方）左右的次数内实现。不过由于[commit id](https://www.zhihu.com/search?q=commit+id&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997}) 是针对单个仓库里的，所以实际应用中我们可以认为如果两个文件的SHA-1值是相同的，那么它们确是完全相同的内容。

*注：对于git里tree、parent等结构感兴趣的同学，可以参考下这篇文章[《Git 内部原理 - Git 对象》](https://link.zhihu.com/?target=https%3A//git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1)，这里由于篇幅原因就不进行深入分析了。*

- **版权校验**
  在数据校验方面的另一个应用场景就是版权的保护或者违禁信息的打击，比如某个小视频，第一个用户上传的时候，我们认为是版权所有者，计算一个hash值存下来。当第二个用户上传的时候，同样计算hash值，如果hash值一样的话，就算同一个文件。这种方案其实也给用户传播违禁文件提高了一些门槛，不是简单的换一个名字或者改一下后缀名就可以躲避掉打击了。（当然这种方式也是可以绕过的，图片的你随便改一下颜色，视频去掉一帧就又是完全不同的hash值了。注意：我没有教你变坏，我只是和你在讨论这个技术。。。）另外我们在社区里，也会遇到玩家重复上传同一张图片或者视频的情况，使用这种校验的方式，可以有效减少cos服务的存储空间。
- **大文件分块校验**
  使用过bt的同学都有经验，在p2p网络中会把一个大文件拆分成很多小的数据各自传输。这样的好处是如果某个小的数据块在传输过程中损坏了，只要重新下载这个块就好。为了确保每一个小的数据块都是发布者自己传输的，我们可以**对每一个小的数据块都进行一个hash的计算**，维护一个hash List，在收到所有数据以后，我们对于这个hash List里的每一块进行遍历比对。这里有一个优化点是如果文件分块特别多的时候，如果遍历对比就会效率比较低。**可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash（Root hash）。**在实际的校验中，我们只需要拿到了正确的Root hash，即可校验Hash List，也就可以校验每一个数据块了。

![img](https://picx.zhimg.com/50/v2-cc3421c1114ae142865cbe96ca46ae22_720w.jpg?source=1940ef5c)

### **4.3 负载均衡**

活动开发同学在应对高星级业务大用户量参与时，都会使用分库分表，针对用户的[openid](https://www.zhihu.com/search?q=openid&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})进行hashtime33取模，就可以得到对应的用户分库分表的节点了。

![img](https://picx.zhimg.com/80/v2-4404138f03b94f2e37333f1f9fae96ed_1440w.webp?source=1940ef5c)

如上图所示，这里其实是分了10张表，openid计算后的hash值取模10，得到对应的分表，在进行后续处理就好。对于一般的活动或者系统，我们一般设置10张表或者100张表就好。

下面我们来看一点复杂的问题，假设我们活动初始分表了10张，运营一段时间以后发现需要10张不够，需要改到100张。这个时候我们如果直接扩容的话，那么所有的数据都需要重新计算Hash值，大量的数据都需要进行迁移。如果更新的是缓存的逻辑，则会导致大量缓存失效，发生`雪崩效应`，导致数据库异常。造成这种问题的原因是hash算法本身的缘故，只要是[取模算法](https://www.zhihu.com/search?q=取模算法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})进行处理，则无法避免这种情况。针对这种问题，我们就需要利用`一致性hash`进行相应的处理了。

`一致性hash`的基本原理是将输入的值hash后，对结果的hash值进行2^32取模，**这里和普通的hash取模算法不一样的点是在[一致性hash算法](https://www.zhihu.com/search?q=一致性hash算法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})里将取模的结果映射到一个环上。**将缓存服务器与被缓存对象都映射到[hash环](https://www.zhihu.com/search?q=hash环&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A890181997})上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一个openid必定会被缓存到固定的服务器上，那么，当下次想要访问这个用户的数据时，只要再次使用相同的算法进行计算，即可算出这个用户的数据被缓存在哪个服务器上，直接去对应的服务器查找对应的数据即可。这里的逻辑其实和直接取模的是一样的。如下图所示：

![img](https://picx.zhimg.com/80/v2-688081f5954e2dffc7504e84fb0a9928_1440w.webp?source=1940ef5c)

初始情况如下：用户1的数据在服务器A里，用户2、3的数据存在服务器C里，用户4的数据存储在服务器B里

下面我们来看一下当服务器数量发生变化的时候，相应影响的数据情况：

- **服务器缩容**

![img](https://pic1.zhimg.com/80/v2-b34f507d3ef512c7a6fa5f28df18675b_1440w.webp?source=1940ef5c)

服务器B发生了故障，进行剔除后，只有用户4的数据发生了异常。这个时候我们需要继续按照顺时针的方案，把缓存的数据放在用户A上面。

- **服务器扩容**
  同样的，我们进行了服务器扩容以后，新增了一台服务器D，位置落在用户2和3之间。按照顺时针原则，用户2依然访问的是服务器C的数据，而用户3顺时针查询后，发现最近的服务器是D，后续数据就会存储到d上面。

![img](https://picx.zhimg.com/80/v2-511a977b9b37a3eb6f9031fabbd460ff_1440w.webp?source=1940ef5c)

- **虚拟节点**
  当然这只是一种理想情况，实际使用中，由于服务器节点数量有限，有可能出现分布不均匀的情况。这个时候会出现大量数据都被映射到某一台服务器的情况，如下图左侧所示。为了解决这个问题，我们采用了`虚拟节点`的方案。`虚拟节点`是`实际节点`（实际的物理服务器）在hash环上的`复制品`，**一个实际节点可以对应多个虚拟节点。虚拟节点越多，hash环上的节点就越多，数据被均匀分布的概率就越大。**

![img](https://picx.zhimg.com/80/v2-a9e789d181d4c2ac8d3c0d47daf47b15_1440w.webp?source=1940ef5c)

如右图所示，B、C、D 是原始节点复制出来的虚拟节点，原本都要访问机器D的用户1、4，分别被映射到了B,D。通过这样的方式，起到了一个服务器均匀分布的作用。

## **5、几种hash算法的扩展应用**

### **5.1 SimHash**

simHash是google用于海量文本去重的一种方法，它是一种局部敏感hash。那什么叫局部敏感呢，**假定两个字符串具有一定的相似性，在hash之后，仍然能保持这种相似性，就称之为局部敏感hash。**普通的hash是不具有这种属性的。simhash被Google用来在海量文本中去重。

simHash算法的思路大致如下：

- 将Doc进行关键词抽取(其中包括分词和计算权重)，抽取出n个(关键词，权重)对， 即图中的多个(feature, weight)。记为 feature_weight_pairs = [fw1, fw2 … fwn]，其中 fwn = (feature_n,weight_n)。
- 对每个feature_weight_pairs中的feature进行hash。然后对hash_weight_pairs进行位的纵向累加，如果该位是1，则+weight,如果是0，则-weight，最后生成bits_count个数字，大于0标记1，小于0标记0
- 最后转换成一个64位的字节，判断重复只需要判断他们的特征字的距离是不是<n (n根据经验一般取3)，就可以判断两个文档是否相似。

![img](https://pic1.zhimg.com/80/v2-5a8c76d8ca9573db3a26acf43ffe63d9_1440w.webp?source=1940ef5c)

如下图所示，当两个文本只有一个字变化时，如果使用普通Hash则会导致两次的结果发生较大改变，而SimHash的局部敏感特性，会导致只有部分数据发生变化。

![img](https://picx.zhimg.com/80/v2-13790885f0925a2e14fdecbd42c7b309_1440w.webp?source=1940ef5c)

### **5.2 GeoHash**

GeoHash将地球作为为一个二维平面进行递归分解。每个分解后的子块在一定经纬度范围内拥有相同的编码。以下图为例，这个矩形区域内所有的点（经纬度坐标）都共享相同的GeoHash字符串，这样既可以保护隐私（只表示大概区域位置而不是具体的点），又比较容易做缓存。

![img](https://pic1.zhimg.com/80/v2-884cb789ab0c83e460531e7a7d9162c4_1440w.webp?source=1940ef5c)

下面以一个例子来理解下这个算法，我们对纬度39.3817进行逼近编码 ：

- 地球纬度区间是[-90,90]，对于这个区间进行二分划分左区间[-90,0), 右区间[0,90]。39.3817属于右区间，标记为1
- 将右区间[0,90]继续进行划分，左区间[0,45) ,右区间[45,90]。39.3817属于左区间，标记为0
- 递归上面的过程，随着每次迭代，区间[a，b]会不断接近39.3817。递归的次数决定了生成的序列长度。
- 对于经度做同样的处理。得到的字符串，偶数位放经度，奇数位放纬度，把2串编码组合生成新串。对于新串转成对应10进制查出实际的base32编码就是类似WX4ER的hash值。

整体递归过程如下表所示：

![img](https://picx.zhimg.com/80/v2-835382381538c450e48b25b062cc1725_1440w.webp?source=1940ef5c)

这里有一篇文章详细介绍了GeoHash，有兴趣的同学可以移步这里：

[腾讯技术工程：app 是如何快速定位我们位置的？深入了解 geohash 算法及其实现](https://zhuanlan.zhihu.com/p/90889887)

### **5.3 布隆过滤器**

布隆过滤器被广泛用于黑名单过滤、垃圾邮件过滤、爬虫判重系统以及缓存穿透问题。对于数量小，内存足够大的情况，我们可以直接用hashMap或者hashSet就可以满足这个活动需求了。但是如果数据量非常大，比如5TB的硬盘上放满了用户的参与数据，需要一个算法对这些数据进行去重，取得活动的去重参与用户数。这种时候，布隆过滤器就是一种比较好的解决方案了。

布隆过滤器其实是基于bitmap的一种应用，在1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数，用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难，主要用于大数据去重、垃圾邮件过滤和爬虫url记录中。核心思路是使用一个bit来存储多个元素，通过这样的方式来减少内存的消耗。通过多个hash函数，将每个数据都算出多个值，存放在bitmap中对应的位置上。

布隆过滤器的原理见下图所示：

![img](https://picx.zhimg.com/80/v2-3e037a3882f1b0728d0b0f8a44b69e2e_1440w.webp?source=1940ef5c)

上图所示的例子中，数据a、b、c经过三次hash映射后，对应的bit位都是1，表示这三个数据已经存在了。而d这份数据经过映射后有一个结果是0，则表明d这个数据一定没有出现过。布隆过滤器存在`假阳率`（判定存在的元素可能不存在）的问题，但是没有`假阴率`（判断不存在的原因可能存在）的问题。即对于数据e，三次映射的结果都是1，但是这份数据也可能没有出现过。

误判率的数据公式如下所示：

![img](https://pica.zhimg.com/50/v2-f73777f6fb5c1318ad1f6a4cc6347850_720w.jpg?source=1940ef5c)![img](https://pica.zhimg.com/80/v2-f73777f6fb5c1318ad1f6a4cc6347850_1440w.webp?source=1940ef5c)

其中，p是误判率，n是容纳的元素，m是需要的存储空间。由公示可以看出，布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，则会导致误报率升高。

## **6、总结**

Hash算法作为一种活动开发经常遇到的算法，我们在使用中不仅仅要知道这种算法背后真正的原理，才可以在使用上做到有的放矢。Hash的相关知识还有很多，有兴趣的同学可以继续深入研究。

更多内容欢迎关注我们：[腾讯技术工程](https://zhuanlan.zhihu.com/tencent-TEG)

# 二叉树

## 前序遍历+中序遍历(值不重复) 构建二叉树

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        for(int i=0; i<inorder.size(); i++)
            this->inorder_hash[inorder[i]] = i;
        return recursion(0, 0, inorder.size()-1);
    }
  
private:
    vector<int> preorder;
    unordered_map<int, int> inorder_hash;
  
    TreeNode* recursion(int root, int left, int right)
    {
        if(left>right)
            return nullptr;
        TreeNode* node = new TreeNode(preorder[root]);
        int i = inorder_hash[preorder[root]];
        node->left = recursion(root+1, left, i-1);
        node->right = recursion(root+i-left+1, i+1, right);
        return node;
    }
};
```

二叉树的前序（preorder）、中序（inorder）、后续（postorder）遍历是非常经典的遍历方式，其中中序遍历较为常用，因为二分查找树按照中序遍历获得的就是有序的数组。

三种遍历的定义：

- 前序遍历：根结点 -> 左子树 -> 右子树
- 中序遍历：左子树 -> 根结点 -> 右子树
- 后序遍历：左子树 -> 右子树 -> 根结点

遍历的实现如果使用递归的方式，就非常容易，与遍历的定义是一致的，不过迭代版本的实现就会复杂一些。

迭代写法的实现思路是通过栈来模拟递归的写法，通过这种方式来去掉递归调用，相对来说不太直观。其中，后序遍历的实现是最为复杂的，在 leetcode 中是 hard 难度的，其余两个是 medium 难度。

递归写法的套路，这里为了减少复制，采用了辅助函数，参数中包含一个输出参数，这是c++常用的一种传出结果的方式。

```cpp
void helper(TreeNode* root, vector<int>& res) {  // res 是结果
    // 递归终止条件
    if (!root) {
        return;
    }

    // 这里根据遍历的顺序来进行调整，即可实现三种遍历
    res.push_back(root->val);
    helper(root->left, res);
    helper(root->right, res);
}
```

使用栈来模拟的模拟套路是类似这样的结构，不同的情况会有一些变形，但是基本模板是这样的。

```cpp
stack<TreeNode*> s;
s.push(x);  // 初始化栈
while (!s.empty()) {  // 栈非空就继续遍历
    TreeNode* cur = s.top();
    s.pop();
    // do something
    
    s.push(x);  // 填充栈
}
```

## 二叉树节点定义

二叉树是包含一个值，左右两个子树，也就是两个指针。

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 前序遍历

### 递归写法

最直接的递归写法如下，缺点是会有比较多的元素复制操作。

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if (root == NULL) {
            return {};
        }

        vector<int> res;
        res.push_back(root->val);
        vector<int> left = preorderTraversal(root->left);
        res.reserve(left.size() + 1);
        res.insert(res.end(), left.begin(), left.end());
        
        vector<int> right = preorderTraversal(root->right);
        res.reserve(left.size() + 1 + right.size());
        res.insert(res.end(), right.begin(), right.end());
        return res;
    }
};
```

为了避免元素复制，可以采用一个辅助方法，将输出参数通过引用的方式传入，这样可以避免不必要的拷贝。

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        helper(root, res);
        return res;
    }

    void helper(TreeNode* root, vector<int>& seq) {
        if (!root) {
            return;
        }
        seq.push_back(root->val);
        helper(root->left, seq);
        helper(root->right, seq);
    }
};
```

### 迭代写法

通过 stack 来模拟递归调用的方式，需要注意的是这里入栈的顺序是先右后左，因为我们的遍历顺序是根左右，先遍历左边，栈的出栈是LIFO，所以需要把左子树入栈放在后面。

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if (!root) {
            return {};
        }
        vector<int> res;
        stack<TreeNode*> s;
        s.push(root);
        while (!s.empty()) {
            TreeNode* cur = s.top();
            s.pop();
            res.push_back(cur->val);
            // 注意：先右后左
            if (cur->right) {
                s.push(cur->right);
            }
            if (cur->left) {
                s.push(cur->left);
            }
        }
        return res;
    }
};
```

## 中序遍历



### 递归写法

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
       vector<int> res;
       helper(root, res);
       return res; 
    }

    void helper(TreeNode* root, vector<int>& res) {
        if (!root) {
            return;
        }
        helper(root->left, res);
        res.push_back(root->val);
        helper(root->right, res);
    }
};
```

### 迭代写法

中序遍历的方式是左根右，我们通过模拟思考递归的算法，会发现他首先的第一个遍历的节点是最左侧的叶子节点，所以这里有一个一直找最左侧节点的循环。

我们来分析最初的两步：

- 在寻找到最左侧的节点后，栈内的元素就已经将该左子树的根节点入栈了，这是第一次出栈的是最左侧节点，然后最左侧节点，只可能有或没有右子树
- 没有右子树，直接出栈最左侧节点的上一个根节点
- 有右子树，当前最右侧节点就是该右子树的根节点，访问该节点，也符合中序遍历的左根右

我们通过模拟递归的方式来分析该逻辑，思路上不是很直观，可以通过递归的调用过程来进行推演。

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if (!root) {
            return {};
        }
        vector<int> res;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while (cur || !s.empty()) {
            while (cur) { // 寻找最左侧的节点
                s.push(cur);
                cur = cur->left;
            }
            cur = s.top();
            s.pop();
            res.push_back(cur->val);
            cur = cur->right;
        }
        return res; 
    }
};
```

## 后续遍历



### 递归写法

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        helper(root, res);
        return res;
    }
    void helper(TreeNode* root, vector<int>& res) {
        if (!root) {
            return;
        }

        helper(root->left, res);
        helper(root->right, res);
        res.push_back(root->val);
    }
};
```

### 迭代写法

后续遍历与前序遍历的关系

- 前序遍历：root, left, right
- 后续遍历: left, right, root

如何从前序遍历得到后续遍历，首先，调换 left 与 right 的位置，得到 root, right, left，然后再翻转 reverse，得到 left, right, root。

所以我们可以根据前序遍历的代码来改为后续遍历，唯一的区别就是，前序遍历的时候是先右后左，后续遍历是先左后右。最后再将结果进行翻转即可。

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if (!root) {
            return {};
        }
        vector<int> res;
        stack<TreeNode*> s;
        s.push(root);
        while (!s.empty()) {
            TreeNode* cur = s.top();
            s.pop();
            res.push_back(cur->val);
            // 注意：先左后右
            if (cur->left) {
                s.push(cur->left);
            }

            if (cur->right) {
                s.push(cur->right);
            }
        }
        reverse(res.begin(), res.end());  // 翻转
        return res;
    }
};
```

#剑指 offer



| 题目                                                         | 通过率 | 题目概述                                                     | 思路                                       |
| :----------------------------------------------------------- | :----- | ------------------------------------------------------------ | :----------------------------------------- |
| [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) | 67.9%  | 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br/><br/> | bool vector                                |
| [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) | 40.2%  | 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br/> | 左下右上                                   |
| [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/) | 76.0%  | 请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。       | easy                                       |
| [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/) | 75.0%  | 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 | 反转链表                                   |
| [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/) | 70.2%  | 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。<br />假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 |                                            |
| [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) | 71.1%  | 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )<br/><br/>来源：力扣（LeetCode）<br/>链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof<br/>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 | s1 输入, s2 输出                           |
| [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/) | 36.2%  | 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br/><br/>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br/> | 只需要保留后两个数, 不用全部存在 vector 里 |
| [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/) | 45.2%  | 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br/><br/>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 | 同上                                       |
| [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/) | 49.2%  | 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br/><br/>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  <br/><br/>注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。<br/> | 二分变形                                   |
| [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/) | 45.3%  |                                                              | dfs                                        |
| [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/) | 53.2%  |                                                              |                                            |
| [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/) | 57.2%  |                                                              |                                            |
| [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/) | 31.6%  |                                                              |                                            |
| [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) | 75.0%  |                                                              | 位运算                                     |
| [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) | 34.4%  |                                                              |                                            |
| [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/) | 77.9%  |                                                              | 大数???                                    |
| [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/) | 60.1%  |                                                              | 内存泄漏                                   |
| [剑指 Offer 19. 正则表达式]                                  |        |                                                              |                                            |
| [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) | 24.9%  |                                                              |                                            |
| [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/) | 64.6%  |                                                              | 双指针                                     |
| [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) | 80.1%  |                                                              | 快慢指针?                                  |
| [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/) | 74.3%  |                                                              | prev cur next                              |
| [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/) | 72.7%  |                                                              | 双指针                                     |
| [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/) | 46.7%  |                                                              |                                            |
| [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/) | 79.3%  |                                                              |                                            |
| [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/) | 57.8%  |                                                              |                                            |
| [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/) | 43.8%  |                                                              | ?                                          |
| [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/) | 55.3%  |                                                              | min栈                                      |
| [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) | 61.8%  |                                                              | 判定有问题[1, 0], 模拟栈                   |
| [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) | 68.7%  |                                                              |                                            |
| [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) | 58.8%  |                                                              |                                            |
| [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) | 55.9%  |                                                              |                                            |
| [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) | 58.4%  |                                                              |                                            |
| [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/) | 71.7%  |                                                              |                                            |
| [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) | 65.3%  |                                                              |                                            |
| [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/) | 56.6%  |                                                              |                                            |
| [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/) | 58.0%  |                                                              | 重复字母?                                  |
| [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/) | 69.7%  |                                                              |                                            |
| [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) | 57.2%  |                                                              |                                            |
| [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) | 58.4%  |                                                              |                                            |
| [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/) | 60.7%  |                                                              | 堆                                         |
| [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) | 49.6%  |                                                              |                                            |
| [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) | 42.3%  |                                                              |                                            |
| [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/) | 55.7%  |                                                              |                                            |
| [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/) | 52.6%  |                                                              |                                            |
| [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/) | 69.1%  |                                                              |                                            |
| [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/) | 46.4%  |                                                              |                                            |
| [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/) | 65.4%  |                                                              |                                            |
| [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) | 48.9%  |                                                              |                                            |
| [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) | 65.4%  |                                                              |                                            |
| [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) | 53.2%  |                                                              |                                            |



# C++

## 拷贝初始化 直接初始化

## final volatile

- final

  直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。

  将方法标记为final，这意味着无法再[子类](https://so.csdn.net/so/search?q=子类&spm=1001.2101.3001.7020)中重写该方法。这时final关键字至于方法参数列表后面，如下

  ```cpp
  class Super final
  {
    //...
  };
  
  class Super
  {
    public:
      Super();
      virtual void SomeMethod() final;
  };
  ```

- volatile

  用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

  当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据

## 菱形继承

解决: 虚继承

虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。

## 多态是什么

- 编译时多态 重载函数
- 运行时多态 虚函数

通过基类指针调用派生类的方法, 实现一个接口多个方法

## [虚函数是怎么实现的](https://jacktang816.github.io/post/virtualfunction/)

每一个有虚函数的类都有一个(不止一个?)指向虚函数表的指针, 里面记录了每个虚函数的地址, 当对象的虚函数被调用时, 通过查找虚函数表来确定调用哪个函数

创建时间: 虚函数表指针-编译时和对象一起, 虚函数表-编译时

多继承, 多虚函数表

**虚函数运行时所需的代价主要是虚函数不能是内联函数**

- 内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码

static 函数不能为 virtual, 因为没有 this 指针, 无法调用 vtb

构造函数不能为 virtual, 因为 virtual func 需要查找 vtb, 会有编译错误

构造函数内可以调用虚函数, 但是无法实现多态

析构函数, 如果可能为基类就要求是 virtual

```c++
class A {
  public:
    virtual void v_a(){}
    virtual ~A(){}
    int64_t _m_a;
};

int main(){
    A* a = new A();
    return 0;
}
```

![img](https://jacktang816.github.io/img/cpp/virtualFunction/vptrLocation.png)

## 指针和引用的区别

 指针是对象, 引用是对象的别名, 且一定不为空

## 智能指针 

防止内存泄露

大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。 在现代 C++ 中，原始指针仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的 Helper 函数中。

```cpp
void UseRawPointer()
{
    Song* pSong = new Song(L"Nothing on You", L"Bruno Mars"); 

    // Use pSong...

    // Don't forget to delete!
    delete pSong;   
}


void UseSmartPointer()
{
    unique_ptr<Song> song2(new Song(L"Nothing on You", L"Bruno Mars"));

    // Use song2...
    wstring s = song2->duration_;
    //...

} // song2 is deleted automatically here.
```

- 分类

  - `unique_ptr`
    在任何时间、资源只能被一个指针占有。 可以移到新所有者，但不会复制或共享。 替换已弃用的 `auto_ptr`。 大小是一个指针. 头文件：`<memory>`。
    在下列两者之一发生时用关联的删除器释放对象：
    - 销毁了管理的 unique_ptr 对象
    - 通过 operator= 或 reset() 赋值另一指针给管理的 unique_ptr 对象。
  - `shared_ptr`
    采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 `shared_ptr` 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。 头文件：`<memory>`。 
    下列情况之一出现时销毁对象并解分配其内存：
    - 最后剩下的占有对象的 shared_ptr 被销毁；
    - 最后剩下的占有对象的 shared_ptr 被通过 operator= 或 reset() 赋值为另一指针。
  - `weak_ptr`
    结合 `shared_ptr` 使用的特例智能指针。 `weak_ptr` 提供对一个或多个 `shared_ptr` 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 `shared_ptr` 实例间的循环引用。 头文件：`<memory>`。 

  （1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：

  - 有一个[指针数组](https://www.zhihu.com/search?q=指针数组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A331873847})，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；
  - 两个对象包含都指向第三个对象的指针；
  - STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。

  （2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。

## Resource acquisition is initialization RAII

## malloc new

由于`malloc/free`是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于`malloc/free`。

## static 作用

- static 变量

  - static 变量 in func

    声明周期和程序本身一样

  - static 变量 in class

    所有对象共享

- static func

  只允许访问静态成员和函数

## memset memcpy strcpy

 strcpy 

```c 
#include <string.h> 
extern char *strcpy(char *dest,char *src);  
```

 功能：把src所指由NULL结束的字符串复制到dest所指的数组中  

说明:src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。  

返回指向dest的指针 

memcpy 

```c
#include <string.h> 
extern void *memcpy(void *dest,void *src,unsigned int count); 
```

 功能：由src所指内存区域复制count个字符串到dest所指内存区域.  

说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针.   

memset  

```c
#include <string.h>  
extern void *memset(void *buffer,int c,int count);  
```

功能：把buffer所指内存区域的前count个字节设置成字符c  

说明：返回指向buffer的指针.

memset 用来对一段内存空间全部设置为某个字符，一般用于在对定义的字符串初始化为' '或者'\0';   

memcpy 是用来做内存拷贝，可以用来拷贝任何数据类型的对象，可以指定拷贝的数据长度； memcpy是见着什么拷贝什么。    

strcpy 就只能拷贝字符串，它遇到'\0'就结束拷贝；    例：char a[100],b[50];        strcpy(a,b);        如用strcpy(b,a)要注意a中的字符串长度(第一个'\0'之前) 是否超过50,如果超过，则会造成b的 内存溢出.它是不会拷贝'\0'的

## 内联函数和宏

宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。

## c++11

auto decltype

左右值

列表初始化

lambda

智能指针

for 循环

final  override

## stl 容器

| 底层实现       | 插入删除                       | 访问      | 查找 | 其他 | 容器           |
| -------------- | ------------------------------ | --------- | ---- | ---- | -------------- |
| 数组           | 尾结点 O(1)<br />非尾结点 O(n) | O(1)      | O(n) | 扩容 | vector         |
| 环状双向链表   | O(1)                           | O(n)      |      |      | list           |
| 堆+中央控制器  | 非首尾 O(n)<br />首尾 O(1)     | O(1)      |      |      | deque          |
| deque          |                                |           |      |      | stack          |
| deque          |                                |           |      |      | queue          |
| 堆(数组无指针) | 最值O(logn)                    |           |      |      | priority_queue |
| 红黑树         | O(logn)                        | O(logn)   |      |      | set            |
| 红黑树         | O(logn)                        | O(logn)   |      |      | map            |
| hash           | O(1)~O(n)                      | O(1)~O(n) |      |      | unordered_set  |
| hash           | O(1)~O(n)                      | O(1)~O(n) |      |      | unordered_map  |

# 网络

## 浏览器输入 URL 后发生了什么？

DNS 解析

TCP 连接

HTTP

tcp 关闭

解析 html



## http1.0/http1.1/http2.0

- http1.1

  默认长链接, 请求hostname

- http2.0

  多路复用 同时发起多重的请求-响应消息

  server push



## 中间人攻击

![img](https://pic3.zhimg.com/80/v2-c181b1f7cf755605bf950dff0182674a_1440w.jpg)

## https

## post get

get 获取资源, 没有副作用 url 携带数据(浏览器), 会被 cache

post 提交表单 body

## content-type

application/x-www-form-urlencoded



## tcp如何保证可靠传输

1. 有序

2. 校验和

3. 丢弃重复数据

4. 流量控制 滑动窗口, 防止包丢失

   ![img](https://pic4.zhimg.com/80/a1d5c050ad957880094a5f003b1ccd24_1440w.jpg?source=1940ef5c)

5. 拥塞控制 cwnd

   ![img](https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_1440w.jpg)

   ![img](https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_1440w.jpg)

   - **慢开始：**即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
   - **拥塞避免：**拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
   - **快重传与快恢复：**在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

6. arq(automatic repeat request) 协议

7. 超时重传

# 组原

## 编译器编译代码的四个过程

（预处理、编译、汇编、链接, 生成可执行文件）

编译 : 扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化

## 内存对齐

> 元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小（通常它为4或8）来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始，这就是所谓的内存对齐。

理论上，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。

## 内存对齐规则

为什么要内存对齐

内存对齐规则

1. **基本类型**的对齐值就是其sizeof值;

2. **数据成员对齐规则**

   1.第一个成员在结构体变量偏移量为0 的地址处，也就是第一个成员必须从头开始。

   2.以后每个成员相对于结构体首地址的 offset 都是该成员大小的整数倍，如有需要编译器会在成员之间加上填充字节。

   3.结构体的总大小为 最大对齐数的整数倍（每个成员变量都有自己的对齐数），如有需要编译器会在最末一个成员之后加上填充字节。

   4.如果嵌套结构体，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍。

```c++
struct test_t {
  int   a;
  long  b;
  short c;
};
//24
struct test_t {
  int   a;
  short b;
  long  c;
};
//16
class  CBase
{
};
//1
class  CBase
{
public :
    CBase( void );
     virtual   ~ CBase( void );
private :
     int    a;
     char   * p;
};
//32 位系统 12
class  CChild :
     public  CBase
{
public :
    CChild( void );
     ~ CChild( void );
private :
     int  b;
};
//16

struct Mystruct3{
    char a;  //1  [0]
    short d; //2   [2 3]
     int c;   //4   [4 5 6 7]
    double b;//8  [8 9 10 11 12 13 14 15]
 }Mystruct3;
 
struct Mystruct4{
    char a;  //1
    int  b;  //4
    struct Mystruct3 struct3; //16  
}Mystruct4;
//4+4+16 = 24
```

This is because of padding added to satisfy alignment constraints. [Data structure alignment](http://en.wikipedia.org/wiki/Data_structure_alignment) impacts both performance and correctness of programs:

- Mis-aligned access might be a hard error (often `SIGBUS`).
- Mis-aligned access might be a soft error.
  - Either corrected in hardware, for a modest performance-degradation.
  - Or corrected by emulation in software, for a severe performance-degradation.
  - In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.

Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):

```csharp
struct X
{
    short s; /* 2 bytes */
             /* 2 padding bytes */
    int   i; /* 4 bytes */
    char  c; /* 1 byte */
             /* 3 padding bytes */
};

struct Y
{
    int   i; /* 4 bytes */
    char  c; /* 1 byte */
             /* 1 padding byte */
    short s; /* 2 bytes */
};

struct Z
{
    int   i; /* 4 bytes */
    short s; /* 2 bytes */
    char  c; /* 1 byte */
             /* 1 padding byte */
};

const int sizeX = sizeof(struct X); /* = 12 */
const int sizeY = sizeof(struct Y); /* = 8 */
const int sizeZ = sizeof(struct Z); /* = 8 */
```

One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure `Z` in the example above).

IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined. Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts. For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data. Some compilers have command-line settings and/or special `#pragma` statements to change the structure alignment settings.



## c++ 内存管理

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
　　**栈**：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
　　**堆**：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
　　**全局/静态存储区** bssdata：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
　　**常量存储区**rodata：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

​		**程序代码区**: 函数

生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。栈效率更高

**一个程序的3个基本段：text段，data段，bss段**

text段在内存中被映射为只读，但data段与bss段是可写的

- text段：代码段，就是放程序代码的，编译时确定，只读
- data段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域
- bss段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。

两者之间区别是：代码段，数据段，堆栈段是cpu级别的概念，五大分区属于语言级别的概念，两者是不同的概念。



# 操作系统

## LRU

```cpp
class LRUCache {
public:
    LRUCache(int capacity) : capacity_(capacity) {}

    int get(int key) {
        if (hash_.find(key) == hash_.end())
            return -1;
        else {
            int value = hash_[key]->second;
            ls_.erase(hash_[key]);
            ls_.push_front(make_pair(key, value));
            hash_[key] = ls_.begin();
            return value;
        }
    }

    void put(int key, int value) {
        if (hash_.find(key) != hash_.end())
            ls_.erase(hash_[key]);
        else if (ls_.size() >= capacity_) {
            hash_.erase(ls_.back().first);
            ls_.pop_back();
        }
        ls_.push_front(make_pair(key, value));
        hash_[key] = ls_.begin();
    }

private:
    int capacity_;
    list<pair<int, int>> ls_;
    unordered_map<int, list<pair<int, int>>::iterator> hash_;
};

```



## 系统调用

操作系统通过系统调用为运行于其上的进程提供服务。

当用户态进程发起一个系统调用， CPU 将切换到 **内核态** 并开始执行一个 **内核函数** 。 内核函数负责响应应用程序的要求，例如操作文件、进行网络通讯或者申请内存资源等。

注解

读者可能会有些疑问——输出文本不是用 printf 等函数吗？

确实是。 printf 是更高层次的库函数，建立在系统调用之上，实现数据格式化等功能。 因此，本质上还是系统调用起决定性作用。

### 调用流程

那么，在应用程序内，调用一个系统调用的流程是怎样的呢？

我们以一个假设的系统调用 xyz 为例，介绍一次系统调用的所有环节。

![../../_images/92b3f2ae7105aa2017ac7f475892aca9.jpg](https://linux.fasionchan.com/zh_CN/latest/_images/92b3f2ae7105aa2017ac7f475892aca9.jpg)

如上图，系统调用执行的流程如下：

> 外中断: io
>
> 内中断: 系统调用, 异常

1. **应用程序** 代码调用系统调用( xyz )，该函数是一个包装系统调用的 **库函数** ；
2. **库函数** ( xyz )负责准备向内核传递的参数，并触发 **软中断** 以切换到内核；
3. CPU 被 **软中断** 打断后，执行 **中断处理函数** ，即 **系统调用处理函数** ( system_call )；
4. **系统调用处理函数** 调用 **系统调用服务例程** ( sys_xyz )，真正开始处理该系统调用；

### 执行态切换

**应用程序** ( application program )与 **库函数** ( libc )之间， **系统调用处理函数** ( system call handler )与 **系统调用服务例程** ( system call service routine )之间， 均是普通函数调用，应该不难理解。 而 **库函数** 与 **系统调用处理函数** 之间，由于涉及用户态与内核态的切换，要复杂一些。

Linux 通过 **软中断** 实现从 **用户态** 到 **内核态** 的切换。 **用户态** 与 **内核态** 是独立的执行流，因此在切换时，需要准备 **执行栈** 并保存 **寄存器** 。

内核实现了很多不同的系统调用(提供不同功能)，而 **系统调用处理函数** 只有一个。 因此，用户进程必须传递一个参数用于区分，这便是 **系统调用号** ( system call number )。 在 Linux 中， **系统调用号** 一般通过 eax **寄存器** 来传递。

总结起来， **执行态切换** 过程如下：

1. **应用程序** 在 **用户态** 准备好调用参数，执行 int 指令触发 **软中断** ，中断号为 0x80 ；
2. CPU 被软中断打断后，执行对应的 **中断处理函数** ，这时便已进入 **内核态** ；
3. **系统调用处理函数** 准备 **内核执行栈** ，并保存所有 **寄存器** (一般用汇编语言实现)；
4. **系统调用处理函数** 根据 **系统调用号** 调用对应的 C 函数—— **系统调用服务例程** ；
5. **系统调用处理函数** 准备 **返回值** 并从 **内核栈** 中恢复 **寄存器** ；
6. **系统调用处理函数** 执行 ret 指令切换回 **用户态** ；

## 生产者消费者

?

## 进程线程区别

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**, 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段

切换开销

进程切换 切换虚拟地址空间，切换内核栈和硬件上下文, 缓存

线程切换 切换内核栈和硬件上下文

## IPC Inter-Process Communication

### pipe 匿名管道

内核开辟缓存区, 一端读一端写, 单向, 只能是父子进程

### fifo 有名管道

半双工, 允许无亲缘关系

### 消息队列

消息链表, 有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。`消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点`

### 信号

### 共享内存

多进程访问同一个块内存

分配 shmget 绑定 shmat

### 套接字

socket 编程



# 算法

## [红黑树](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)

![img](https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png)

本质上是平衡的二叉查找树

> 1）每个结点要么是红的，要么是黑的。  
> 2）根结点是黑的。  
> 3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
> 4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
> 5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  

## 排序

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h0pr8a32oxj218z0u0n24.jpg)

冒泡排序时间复杂度最好情况 O(n^2)

快速排序递归栈空间复杂度 O(logn)~O(n)

### 冒泡排序

```c++
void bubbleSort(vector<int> &a)
{
    int len = a.size();
    for (int i = 0; i < len - 1; i++) //需要循环次数
    {
        for (int j = 0; j < len - 1 - i; j++) //每次需要比较个数
            if (a[j] > a[j + 1])
                swap(a[j], a[j + 1]); //不满足偏序，交换
    }
}
每次都从头冒泡
每次冒泡能确定最后一个元素
等于不交换就稳定 
```

### 选择排序

```cpp
void selectionSort(vector<int> &a)
{
    int len = a.size();
    for (int i = 0, minIndex; i < len - 1; i++) //需要循环次数
    {
        minIndex = i;                     //最小下标
        for (int j = i + 1; j < len; j++) //访问未排序的元素
        {
            if (a[j] < a[minIndex])
                minIndex = j; //找到最小的
        }
        swap(a[i], a[minIndex]);
    }
}
每次选出最小的元素
每个循环确定最前面的一个元素
不稳定 5 8 5 2 9, 2 8 5 5 9
  
```

### 插入排序

```cpp
void insertionSort(vector<int> &a)
{
    int len = a.size();
    for (int i = 0, j, temp; i < len - 1; i++) //需要循环次数
    {
        j = i;
        temp = a[i + 1];
        while (j >= 0 && a[j] > temp)
        {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = temp;
    }
}
稳定
前端有序
```

### 快速排序

```cpp
void quicksort (int arr[], int start, int end)
{
    if (start < end)
    {
        int p = partition(arr, start, end);
        quicksort(arr, start, p - 1);
        quicksort(arr, p + 1, end);
    }
}
int partition(int arr[], int start, int end)
{
    int pivotValue = arr[start];
    int pivotPosition = start;
    
    for (int pos = start + 1; pos <= end; pos++)
    {
        if (arr[pos] < pivotValue)
        {
            swap(arr[pivotPosition + 1], arr[pos]);
            swap(arr[pivotPosition], arr[pivotPosition + 1]);
            pivotPosition ++;
        }
    }
    return pivotPosition;
}
不稳定
正序或者逆序有最坏时间复杂度
递归栈空间复杂度 O(logn)~O(n)
```

### 归并排序

```cpp
template<typename T>
void merge_sort_recursive(T arr[], T reg[], int start, int end) {
    if (start >= end)
        return;
    int len = end - start, mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
  
    int k = start;
    while (start1 <= end1 && start2 <= end2)
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 <= end1)
        reg[k++] = arr[start1++];
    while (start2 <= end2)
        reg[k++] = arr[start2++];
    for (k = start; k <= end; k++)
        arr[k] = reg[k];
}

template<typename T>
void merge_sort(T arr[], const int len) {
    T reg[len];
    merge_sort_recursive(arr, reg, 0, len - 1);
}
稳定
```

### 堆排序

```cpp
void adjustHeap(vector<int> &a, int i,int len)
{
    int maxIndex = i;
    //如果有左子树，且左子树大于父节点，则将最大指针指向左子树
    if (i * 2 + 1 < len && a[i * 2 + 1] > a[maxIndex])
        maxIndex = i * 2 + 1;
    //如果有右子树，且右子树大于父节点和左节点，则将最大指针指向右子树
    if (i * 2 + 2 < len && a[i * 2 + 2] > a[maxIndex])
        maxIndex = i * 2 + 2;
    //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
    if (maxIndex != i)
    {
        swap(a[maxIndex], a[i]);
        adjustHeap(a, maxIndex,len);
    }
}

void Sort(vector<int> &a)
{
    int len = a.size();
    //1.构建一个最大堆
    for (int i = len / 2 - 1; i >= 0; i--) //从最后一个非叶子节点开始
    {
        adjustHeap(a, i,len);
    }
    //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆

    for (int i = len - 1; i > 0; i--)
    {
        swap(a[0], a[i]);
        adjustHeap(a, 0, i);
    }
}
不稳定
```

### 希尔排序

```cpp
template<typename T>
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```



## B树

## 二叉搜索树

> 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
>
> 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
>
> 任意节点的左、右子树也分别为二叉查找树；
>
> **没有键值相等的节点**

查找插入 O(logn)~O(n)

插入: 总是插入叶子节点

删除叶子节点: 直接删除

删除有一个子节点的节点: 替换

删除有两个子节点的节点: 则将其右子树的最小数据代替此节点的数据

中序遍历从小到大

## 平衡二叉树

为了防止退化成线性表 O(n)

左右层级不大于 1

（1）非叶子节点最多拥有两个子节点；

（2）非叶子节值大于左边子节点、小于右边子节点；

（3）树的左右两边的层级数相差不会大于1;

## [堆(priority_queue)](https://blog.csdn.net/changyuanchn/article/details/14564403)

它能够使插入（Insert）和删除最值（Delete）这两种操作的最坏时间复杂度为O(N)，而插入的平均时间复杂度为常数时间，即O(1)。

Heap（堆）是一个除了底层节点外的**完全填满的二叉树**，底层可以不完全，左到右填充节点。

（a）完全二叉树；（b）父节点小于后继子节点

堆的插入是按照顺序插入到底层的结点上，然后与他的父节点比较，如果小于父节点，那么此结点与父节点交换位置，否则，这个位置就是应该插入的位置，依次循环

## 链表与数组

- 链表

  插入删除快, 内存利用率, 可扩展

- 数组

  空间少, 随机访问

## 链表中环的检测

- hash

- 快慢指针

  我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与slow 指针在环中相遇。

  ```cpp
  class Solution {
  public:
      ListNode *detectCycle(ListNode *head) {
          ListNode *slow = head, *fast = head;
          while (fast != nullptr) {
              slow = slow->next;
              if (fast->next == nullptr) {
                  return nullptr;
              }
              fast = fast->next->next;
              if (fast == slow) {
                  ListNode *ptr = head;
                  while (ptr != slow) {
                      ptr = ptr->next;
                      slow = slow->next;
                  }
                  return ptr;
              }
          }
          return nullptr;
      }
  };
  ```

  

  

# 项目

- [PIPE](https://ty-chen.github.io/linux-kernel-pipe/)

  

# beyond coding

## 单例模式

```c++
class Singleton
{
private:
	static Singleton* instance;
private:
	Singleton() {};
	~Singleton() {};
public:
	static Singleton* getInstance() 
  {
		if(instance == NULL) 
			instance = new Singleton();
		return instance;
	}
};
```



## 测试

[Software Testing](https://www.geeksforgeeks.org/software-testing-basics/) can be majorly classified into two categories: 

1. [**Black Box Testing**](https://www.geeksforgeeks.org/software-engineering-black-box-testing/) is a software testing method in which the internal structure/ design/ implementation of the item being tested is **not known to the tester** 
2. [**White Box Testing**](https://www.geeksforgeeks.org/software-engineering-white-box-testing/) is a software testing method in which the internal structure/ design/ implementation of the item being tested is **known to the tester.**

| Black Box Testing                                            | White Box Testing                                            |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| It is a way of software testing in which the internal structure or the program or the code is hidden and nothing is known about it. | It is a way of testing the software in which the tester has knowledge about the internal structure or the code or the program of the software. |
| It is mostly done by software testers.                       | It is mostly done by software developers.                    |
| No knowledge of implementation is needed.                    | Knowledge of implementation is required.                     |
| It can be referred as **outer** or external software testing. | It is the inner or the **internal** software testing.        |
| It is **functional** test of the software.                   | It is **structural** test of the software.                   |
| This testing can be initiated on the basis of requirement specifications document. | This type of testing of software is started after detail design document. |
| No knowledge of programming is required.                     | It is mandatory to have knowledge of programming.            |
| It is the behavior testing of the software.                  | It is the logic testing of the software.                     |
| It is applicable to the higher levels of testing of software. | It is generally applicable to the lower levels of software testing. |
| It is also called closed testing.                            | It is also called as clear box testing.                      |
| It is least time consuming.                                  | It is most time consuming.                                   |
| It is not suitable or preferred for algorithm testing.       | It is **suitable for algorithm testing.**                    |
| Can be done by trial and error ways and methods.             | Data domains along with inner or internal boundaries can be better tested. |
| **Example:** search something on google by using keywords    | **Example:** by input to check and verify loops              |
| **Types of Black Box Testing:**   A. Functional Testing   B. Non-functional testing   C. Regression Testing | **Types of White Box Testing:**   A. Path Testing   B. Loop Testing   C. Condition testing |

# 深信服笔试

## 二叉树遍历方法互求

### 已知前中序求后序

前序遍历:     GDAFEMHZ

中序遍历:     ADEFGHMZ

前序知道根节点, 中序划分左右

### 已知中后序求前序

中序遍历:    ADEFGHMZ

后序遍历:    AEFDHZMG

前序知道根节点, 中序划分左右

## sizeof

```cpp
int main(int argc, const char * argv[]) {
    // insert code here...
    char a[100];
    char * p = a;
    cout<<sizeof(p)<<endl;
    cout<<sizeof(a)<<endl;
    cout<<sizeof(&(*a))<<endl;
}

8 100 8
```

## 大端小端

```cpp
int main(int argc, const char * argv[]) {
    // insert code here...
    const char* str = "\x12\x34\x56\x78";
    printf("%x", *(int*)str);
  
}
78563412
```

## arrays of reference

Answering to your question about standard I can cite the **C++ Standard §8.3.2/4**:

> There shall be no references to references, **no arrays of references**, and no pointers to references.

That's because references are not objects and doesn't occupy the memory so doesn't have the address. You can think of them as the aliases to the objects. Declaring an array of nothing has not much sense.

## fork 权限

1 fork()系统调用
fork()系统调用用来生成子进程，而现有Linux系统运行在写时拷贝的机制下，于是fork()函数在为子进程建立内核中各种管理结构的时候，并没有将真实的物理资源分配给子进程，而只是将父进程的物理资源共享给子进程，比如：fork()函数会将父进程的物理内存共享给子进程，即将父进程多级页表的内容复制到子进程新建立的多级页表中。然而在这种机制下，对于父进程中那些原本可读可写的页，一旦被共享给子进程之后，两个进程中任何一个对该物理页内容进行了修改，将会影响另外一个进程的正常使用，于是，内核解决此问题的方法是：**在将父进程的多级页表复制到子进程的多级页表中时，会将之前对于父进程来说可写的物理页对应的页表项，在父子进程的多级页表中都设置为只读，**因此，一旦两个进程中的任何一个对某个写保护（只读）的物理页发生了写操作，就会导致pagefault，相应的内核函数会处理并识别出这种写时拷贝机制导致的错误，并复制该物理页的内容到一个新的物理页，并将新的物理页链接到发生写操作的进程的多级页表中，最后恢复该物理页对应表项的写权限，恢复进程对该物理页的写操作，做到进程无感知的处理。
————————————————
版权声明：本文为CSDN博主「北方南方」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wangwei222/article/details/80927255

## 数组调用构造函数

```cpp
class A{
    public :
    A(){
        cout<<"A";
    }
};

int main(int argc, const char * argv[]) {
    A a[10];
}

//AAAAAAAAAA
```

## 最大公约数

辗转相除

```cpp
int gcd(int a, int b){
    if(a%b == 0)
        return b;
    else
        return gcd(b, a%b);
}

int main(){
    int a, b;
    cin>>a>>b;
    int ans = 1;
    int left = gcd(a, b);
    cout<<left<<endl;
}
```

## 入侵主机

```java
public class s2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int x = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++){
            nums[i] = scanner.nextInt();
        }
      
        int res = 0;
        int curMax = -1, curMin = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++){
            if (curMax < nums[i]){
                curMax = nums[i];
            }
            if (curMin > nums[i]){
                curMin = nums[i];
            }
            if (Math.abs(x + curMin - curMax) > x){
                res++;
                if (curMax == nums[i]){
                    curMin = curMax;
                }else {
                    curMax = curMin;
                }
            }
        }
        System.out.println(res);
    }
}

```

# 深信服面试

## 多态

多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。

## new delete malloc free 区别

## `new` / `delete`

- Allocate / release memory
  1. Memory allocated from 'Free Store'.
  2. Returns a fully typed pointer.
  3. `new` (standard version) never returns a `NULL` (will throw on failure).
  4. Are called with Type-ID (compiler calculates the size).
  5. Has a version explicitly to handle arrays.
  6. Reallocating (to get more space) not handled intuitively (because of copy constructor).
  7. Whether they call `malloc` / `free` is implementation defined.
  8. Can add a new memory allocator to deal with low memory (`std::set_new_handler`).
  9. `operator new` / `operator delete` can be overridden legally.
  10. **Constructor / destructor used to initialize / destroy the object.**

## `malloc` / `free`

- Allocate / release memory
  1. Memory allocated from 'Heap'.
  2. Returns a `void*`.
  3. Returns `NULL` on failure.
  4. Must specify the size required in bytes.
  5. Allocating array requires manual calculation of space.
  6. Reallocating larger chunk of memory simple (no copy constructor to worry about).
  7. They will **NOT** call `new` / `delete`.
  8. No way to splice user code into the allocation sequence to help with low memory.
  9. `malloc` / `free` can **NOT** be overridden legally.

## Table comparison of the features:

| Feature                             | `new` / `delete`               | `malloc` / `free`            |
| :---------------------------------- | :----------------------------- | :--------------------------- |
| Memory allocated from               | 'Free Store'                   | 'Heap'                       |
| **Returns**                         | Fully typed pointer            | `void*`                      |
| **On failure**                      | Throws (never returns `NULL`)  | Returns `NULL`               |
| Required size                       | Calculated by compiler         | Must be specified in bytes   |
| Handling arrays                     | Has an explicit version        | Requires manual calculations |
| Reallocating                        | Not handled intuitively        | Simple (no copy constructor) |
| Call of reverse                     | Implementation defined         | No                           |
| Low memory cases                    | Can add a new memory allocator | Not handled by user code     |
| Overridable                         | Yes                            | No                           |
| **Use of constructor / destructor** | Yes                            | No                           |



Technically, memory allocated by `new` comes from the 'Free Store' while memory allocated by `malloc` comes from the 'Heap'. Whether these two areas are the same is an implementation detail, which is another reason that `malloc` and `new` cannot be mixed.

## 指针与引用区别

引用只能在定义时被初始化

引用没有 const

引用不可以为空

引用不需要分配内存空间

## 红黑树

## lru lfu

# 阿里面试

## 多个源文件共用一个变量

- 关于全局变量与静态全局变量

  静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

C++中关于不同编译模块中全局的静态变量初始化顺序是不确定的, **也就是说如果两个全局的静态变量定义在不同的文件，而且其中一个变量A的初始化需要依赖于另一个变量B的初始化,** 那么就有可能出现莫名其妙的问题，这是因为编译器不能保证A和B初始化顺序，那么在A初始化的时候B有可能没有初始化，从而使用了未初始化的B，这是非常危险的

这里我们利用C++的一个保证：**函数内局部的静态对象（在函数内声明为static的对象）会在该函数被调用期间首次遇到该对象之定义式时被初始化。**我们可以这样来分析，静态对象的存储区域位于静态区，同理在编译期时，如果存在该函数的调用，那么函数内局部静态对象的符号就已经和一段静态区域的内存绑定映射了，只是它的作用域位于函数内，而我们知道调用函数，其实就是调用子程序，也就是函数内的代码，那么C++的这个保证也就意味着我们在函数内第一次定义该局部静态对象时，**如果未初始化，则该对象就会映射到一块区域值为0的内存，也就是我们说的默认初始化值为0（整形静态变量）**，如果我们指定了初始化，则默认会在函数内第一次定义式后续的指令之前插入一条初始化指令，以保证该对象被初始化，这样当我们调用函数时，就能保证得到初始化的值了。

所以较好的构造全局对象的方法应该是，将全局性的静态变量定义为局部性的静态变量，并通过一个函数返回，如果想改变该对象的值，则返回该对象的引用，否则直接按值返回就行啦。至于这个函数你即可以按照C的方式定义，也可以定义为类中的一个静态函数。如下：

```cpp
Golobal.hpp:
int& a();
	
class Test_C{
public:
	static int b();	
};

Golobal.cpp:
#include "Golobal.hpp" 
int& a(){
	static int a = 3;
	return a;	
}
int Test_C::b(){
	static int b = a();
	return b;
}

main.cpp:
#include <iostream>
#include "Golobal.hpp"
using namespace std;

int main(int argc, char *argv[])
{
	cout<<"a:"<<a()<<" b:"<<Test_C::b()<<endl;
	int& c = a();
	c = 4;
	cout<<"a:"<<a()<<" b:"<<Test_C::b()<<endl;
	return 0;
}
```

## 静态 static

### Storage class specifiers

> A storage class specifier is used to refine the declaration of a variable, a function, and parameters. Storage classes determine whether:
>
> - The object has internal, external, or no linkage
> - The object is to be stored in memory or in a register, if available
> - The object receives the default initial value of 0 or an indeterminate default initial value
> - The object can be referenced throughout a program or only within the function, block, or source file where the variable is defined
> - The storage duration for the object is maintained throughout program run time or only during the execution of the block where the object is defined

The `static` specifier is only allowed in the declarations of objects (except in function parameter lists), declarations of functions (except at block scope), and declarations of anonymous unions.

 When used in a declaration of a **class member**, it declares a [static member](https://en.cppreference.com/w/cpp/language/static). 

- Static members of a class are not associated with the objects of the class: they are independent variables with [static or thread (since C++11) storage duration](https://en.cppreference.com/w/cpp/language/storage_duration) or regular functions.

When used in a declaration of an **object**, it specifies static **storage duration** (except if accompanied by `thread_local`). 

- ***static*** storage duration. **The storage for the object is allocated when the program begins and deallocated when the program ends.** Only one instance of the object exists. All objects declared at namespace scope (including global namespace) have this storage duration, plus those declared with `static` or `extern`. See [Non-local variables](https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables) and [Static local variables](https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables) for details on initialization of objects with this storage duration.

- Variables declared at block scope with the specifier `static` or `thread_local` (since C++11) have static or thread (since C++11) storage duration **but are initialized the first time control passes through their declaration (unless their initialization is [zero-](https://en.cppreference.com/w/cpp/language/zero_initialization) or [constant-initialization](https://en.cppreference.com/w/cpp/language/constant_initialization), which can be performed before the block is first entered).** On all further calls, the declaration is skipped.

  **If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once** (similar behavior can be obtained for arbitrary functions with [std::call_once](https://en.cppreference.com/w/cpp/thread/call_once)).Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.

  The destructor for a block-scope static variable [is called at program exit](https://en.cppreference.com/w/cpp/utility/program/exit), but only if the initialization took place successfully.

When used in a declaration at **namespace scope,** it specifies internal linkage

## 构造函数析构函数异常

### 构造函数可以抛出异常。

1. [构造函数](https://so.csdn.net/so/search?q=构造函数&spm=1001.2101.3001.7020)中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。
2. 因为[析构函数](https://so.csdn.net/so/search?q=析构函数&spm=1001.2101.3001.7020)不能被调用，所以可能会造成内存泄露或系统资源未被释放。
3. 构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露。

### C++标准指明析构函数不能、也不应该抛出异常。

C++异常处理模型是为C++语言量身设计的，更进一步的说，它实际上也是为C++语言中面向对象而服务的。C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。

### more effective c++提出两点理由（析构函数不能抛出异常的理由）：

1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

## 多进程多线程上下文切换

### 线程

上下文: 寄存器, PC

### 进程

上下文: 进程地址空间, 寄存器, PC

## exit-1 和 main return -1

Actually, there *is* a difference, but it's subtle. It has more implications for C++, but the differences are important.

When I call `return` in `main()`, destructors will be called for my locally scoped objects. If I call `exit()`, **no destructor will be called for my locally scoped objects!** Re-read that. `exit()` **does not return**. That means that once I call it, there are "no backsies." Any objects that you've created in that function will not be destroyed. Often this has no implications, but sometimes it does, like closing files (surely you want all your data flushed to disk?).

Note that `static` objects will be cleaned up even if you call `exit()`. Finally note, that if you use `abort()`, no objects will be destroyed. That is, no global objects, no static objects and no local objects will have their destructors called.

**Proceed with caution when favoring exit over return.**

## 迪杰斯特拉算法 加第二限制?

## folk



# 面试题收集

## **在进行网络通信时是否需要进行字节序转换？**

相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。

**网络通信一般使用大端**

原因如下：**网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。**小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。

**网络字节序**

网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; **UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,**这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;

## 核心态 用户态

| **Kernel-mode vs User mode** | In kernel mode, the program has direct and unrestricted access to system resources. | In user mode, the application program executes and starts.   |
| :--------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Interruptions**            | In Kernel mode, the whole operating system might go down if an interrupt occurs | In user mode, a single process fails if an interrupt occurs. |
| **Modes**                    | Kernel mode is also known as the master mode, privileged mode, or system mode. | User mode is also known as the unprivileged mode, restricted mode, or slave mode. |
| **Virtual address space**    | In kernel mode, all processes share a single virtual address space. | In user mode, all processes get separate virtual address space. |
| **Level of privilege**       | In kernel mode, the applications have more privileges as compared to user mode. | While in user mode the applications have fewer privileges.   |
| **Restrictions**             | As kernel mode can access both the user programs as well as the kernel programs there are no restrictions. | While user mode needs to access kernel programs as it cannot directly access them. |
| **Mode bit value**           | The mode bit of kernel-mode is 0.                            | While; the mode bit of user-mode is 1.                       |
| Memory References            | It is capable of referencing both memory areas.              | It can only make references to memory allocated for user mode. |
| System Crash                 | A system crash in kernel mode is severe and makes things more complicated. | In user mode, a system crash can be recovered by simply resuming the session. |
| Access                       | Only essential functionality is permitted to operate in this mode. | User programs can access and execute in this mode for a given system. |
| Functionality                | The kernel mode can refer to any memory block in the system and can also direct the CPU for the execution of an instruction, making it a very potent and significant mode. | The user mode is a standard and typical viewing mode, which implies that information cannot be executed on its own or reference any memory block; it needs an Application Protocol Interface (API) to achieve these things. |

**在下列情况下有用户态自动转向管态(中断发生, 中断返回)**

1. 用户进程访问操作系统, 要求操作系统的某种服务, 这种访问称为<u>系统功能调用</u>
2. 在一个用户进程中产生一个错误状态, 这种状态被处理为程序性中断
3. 在用户程序执行时, 发生一次中断
4. 在用户态下企图执行一条特权指令, 作为一种特殊类型的错误, 按照情况三处理

https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt

**Exceptions** are classified as **faults**, **traps**, or **aborts** depending on the way they are reported and whether the instruction that caused the exception can be restarted without loss of program or task continuity.

A **[trap](http://en.wikipedia.org/wiki/Kernel_trap)** is an **exception** in a user process. **It's the usual way to invoke a kernel routine (a [system call](http://en.wikipedia.org/wiki/System_call))** because those run with a higher priority than user code. Handling is synchronous (so the user code is suspended and continues afterwards). In a sense they are "active" - most of the time, the code expects the trap to happen and relies on this fact.

An **[interrupt](http://en.wikipedia.org/wiki/Interrupt)** is something **generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc**). These are asynchronous (i.e. they don't happen at predictable places in the user code) or "passive" since the interrupt handler has to wait for them to happen eventually.

**Vectored Events** (**interrupts** and **exceptions**) cause the processor to jump into an interrupt handler after saving much of the processor's state (enough such that execution can continue from that point later).

Exceptions and interrupts have an ID, called a vector, that determines which interrupt handler the processor jumps to. Interrupt handlers are described within the **Interrupt Descriptor Table.**



### 中断及其处理

#### 概念

**指某个时间发生时, 系统终止现行程序的运行, 引出处理该事件的程序进行处理, 处理完毕后返回断点继续执行**

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9jczvbcrj30rs0sx1cl.jpg" alt="image-20201101115909104" style="zoom:25%;" />

#### 类型

**按照功能分类**

1. <u>输入输出中断</u>
2. <u>外中断: 如时钟中断, 操作员控制台中断</u>
3. <u>机器故障中断: 如电源故障</u>
4. <u>程序性中断: 程序性质的错误</u>
5. <u>访管中断: 对操作系统提出某种需求(INT)时所发出的中断</u>

**按照中断方式分类**

1. 强迫性中断: 由某种事故或外部请求信号引起的
2. 自愿中断(INT): 这种事件是由于运行程序请求操作系统服务引起的

**按照中断来源分类**

1. 外中断(中断): 由处理机外部事件引起的中断成为外中断, 在 x86 中称为异步中断. 包括 I/O中断, 外中断
2. 俘获: 由处理机内部时间引起的中断成为俘获, x86 中称为异常, 也成同步中断. 包括访管中断, 程序性中断, 机器故障中断

#### 向量中断

向量中断: 硬件提供入口地址, 非向量中断: 只有一个入口地址, 软件通过标志位进行判断是哪个中断

由中断源自己引导处理机进入中断服务程序的中断过程称为向量中断

中断向量包含两个字: 第一个字含有中断服务例程的入口地址, 第二个字是服务程序所用的处理机状态字

所有中断向量放在一起组成中断向量表

#### 中断进入

发现中断源而产生中断过程的设备称为中断装置(中断器)

1. 保护现场和恢复现场

2. 程序状态字: 主要包括: 程序当前应执行的指令, 当前指令执行情况, 处理机所在状态, 程序在执行时应屏蔽的中断, 寻址方法编址保护键, 响应中断的内容, 小型机(X86)包括 CS:IP 和 FLAGS

3. **中断响应**: 中断响应的实质是交换 用户程序和处理该中断事件的中断程序的 指令执行地址和处理器状态

   <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk9jsya3zjj31i70rs4qp.jpg" alt="image-20201101121433659" style="zoom:50%;" />

硬件负责中断的发现, 响应中断请求, 把中断的原因和断点记下来供软件处理时查用; 

软件的中断处理程序负责中断分析, 中断处理

#### ☆软件中断处理过程

包括三步

1. 保护现场和传递参数
2. 执行响应的中断(自陷)服务例程
3. 恢复和退出中断

##### 中断服务的主要内容

- 硬件故障的中断处理
- 程序性中断事件的处理
- 外部中断时间的处理
  - 时钟中断事件的处理
  - 控制台中断事件的处理
- 外部设备中断的处理
  - 传输结束中断的处理
  - 传输错误中断的处理
  - 故障中断的处理

## folk

Fork system call is used for creating a new process, which is called **child process**, which runs concurrently with the process that makes the fork() call (parent process). After a new child process is created, both processes will execute the next instruction following the fork() system call. A child process uses the same pc(program counter), same CPU registers, same open files which use in the parent process.

It takes no parameters and returns an integer value. Below are different values returned by fork().

***Negative Value\***: creation of a child process was unsuccessful.
***Zero\***: Returned to the newly created child process.
***Positive value\***: Returned to parent or caller. The value contains process ID of newly created child process.

> Note: fork() is threading based function, to get the correct output run the program on a local system.

1. Predict the Output of the following program:

   ```c
   #include <stdio.h>
   #include <sys/types.h>
   #include <unistd.h>
   int main()
   {
       fork();
       printf("Hello world!\n");
       return 0;
   }
   ```

   Output:

   ```
   Hello world!
   Hello world!
   ```

2. Calculate number of times hello is printed:

   ```c
   #include <stdio.h>
   #include <sys/types.h>
   int main()
   {
       fork();
       fork();
       fork();
       printf("hello\n");
       return 0;
   }
   ```

   Output:

   ```
   hello
   hello
   hello
   hello
   hello
   hello
   hello
   hello
   ```

   Let us put some label names for the three lines:

   ```
   fork ();   // Line 1
   fork ();   // Line 2
   fork ();   // Line 3
   
          L1       // There will be 1 child process 
       /     \     // created by line 1.
     L2      L2    // There will be 2 child processes
    /  \    /  \   //  created by line 2
   L3  L3  L3  L3  // There will be 4 child processes 
                   // created by line 3
   ```

   So there are total eight processes (new child processes and one original process).

   If we want to represent the relationship between the processes as a tree hierarchy it would be the following:

   The main process: P0
   Processes created by the 1st fork: P1
   Processes created by the 2nd fork: P2, P3
   Processes created by the 3rd fork: P4, P5, P6, P7

   

   ```
                P0
            /   |   \
          P1    P4   P2
         /  \          \
       P3    P6         P5
      /
    P7
   ```

3. Predict the Output of the following program:

   ```c
   #include <stdio.h>
   #include <sys/types.h>
   #include <unistd.h>
   void forkexample()
   {
       if (fork() == 0)
           printf("Hello from Child!\n");
       else
           printf("Hello from Parent!\n");
   }
   
   int main()
   {
       forkexample();
       return 0;
   }
   ```

   

   Output:

   ```
   1.
   Hello from Child!
   Hello from Parent!
        (or)
   2.
   Hello from Parent!
   Hello from Child!
   ```

   In the above code, a child process is created. fork() returns 0 in the child process and positive integer in the parent process.
   Here, two outputs are possible because the parent process and child process are running concurrently. So we don’t know whether the OS will first give control to the parent process or the child process.

   **Important:** Parent process and child process are running the same program, but it does not mean they are identical. OS allocate different data and states for these two processes, and the control flow of these processes can be different. See next example:

4. Predict the Output of the following program:

   ```c
   #include <stdio.h>
   #include <sys/types.h>
   #include <unistd.h>
     
   void forkexample()
   {
       int x = 1;
       if (fork() == 0)
           printf("Child has x = %d\n", ++x);
       else
           printf("Parent has x = %d\n", --x);
   }
   int main()
   {
       forkexample();
       return 0;
   }
   ```

   

   Output:

   ```
   Parent has x = 0
   Child has x = 2
        (or)
   Child has x = 2
   Parent has x = 0
   ```

   Here, global variable change in one process does not affected two other processes because data/state of two processes are different. And also parent and child run simultaneously so two outputs are possible.

**fork() vs exec()**

The fork system call creates a new process. The new process created by fork() is a copy of the current process except for the returned value. **The exec() system call replaces the current process with a new program.**

**Exercise:**

1. A process executes the following code:

   ```c
   for (i = 0; i < n; i++)
       fork();
   ```

   The total number of child processes created is: (B)
   (A) n
   (B) 2^n – 1
   (C) 2^n
   (D) 2^(n+1) – 1;

   See [this](https://www.geeksforgeeks.org/gate-gate-cs-2008-question-66/) for solution.

2. Consider the following code fragment:

   ```c
   if (fork() == 0) {
   	a = a + 5;
   	printf("%d, %d\n", a, &a);
   }
   else {
   	a = a –5;
   	printf("%d, %d\n", a, &a);
   }
   ```

   Let u, v be the values printed by the parent process, and x, y be the values printed by the child process. Which one of the following is TRUE? (c)

   **注意, 两个变量的物理地址不同, 但是虚拟地址相同, 仔细想一想?**

   (A) u = x + 10 and v = y
   (B) u = x + 10 and v != y
   (C) u + 10 = x and v = y
   (D) u + 10 = x and v != y
   See [this](https://www.geeksforgeeks.org/gate-gate-cs-2005-question-72/) for solution.

3. Predict output of below program.

   ```c
   #include <stdio.h>
   #include <unistd.h>
   int main()
   {
   	fork();
   	fork() && fork() || fork();
   	fork();
   
   	printf("forked\n");
   	return 0;
   }
   ```

   a -> b

4. 

## 孤儿进程 僵尸进程

1. **孤儿进程**：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。

2. **僵尸进程**：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。

3. **如何解决僵尸进程**：

   （1）一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用**wait系统调用**；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。

## 进程通信

进程间通信主要包括**管道**、**系统IPC**（包括消息队列、信号量、信号、共享内存）、**套接字socket**。

1. **管道**：包括无名管道和命名管道，无名管道半双工，只能用于具有亲缘关系的进程直接的通信（父子进程或者兄弟进程），可以看作一种特殊的文件；命名管道可以允许无亲缘关系进程间的通信。

2. **系统IPC**

   **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

   **信号量semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。

   **信号**：用于通知接收进程某个事件的发生。

   **内存共享**：使多个进程访问同一块内存空间。

3. **套接字socket**：用于不同主机直接的通信。

## 进程同步

1. **信号量semaphore**：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。
2. **管道**：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
3. **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

## 面向对象特性

封装、继承和多态是面向对象编程的三大特征。

### 1.封装

#### 1.1.封装概念

封装就是把抽象出的数据（**属性**）和对数据的操作（**方法**）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（**方法**）才能对数据进行操作。

如：我们通过遥控器对电视机的操作就属于典型的封装。

#### 1.2.封装的好处

1. 隐藏实现的细节

一个操作具体的实现过程往往很复杂，通过封装用户和调用者可以直接使用**提供的方法**进行操作，不用关心其实现细节。

2. 可以对数据进行**验证**，保证其安全合理

进行封装后，**私有化类的成员变量**，类中的实例变量**不能直接进行查看和修改**，用户需要通过**提供的getter和setter方法**才能操作，在方法中可以对用户输入的数据进行验证，从而控制数据的范围。

#### 1.3.封装的实现步骤

1. 将属性进行私有化private （不能直接修改属性）
2. 提供公共的setter方法，用于对属性判断并赋值
3. 提供公共的getter方法，用于获取属性的值

### 2.继承

#### 2.1.继承概念

继承可以提高代码的复用性，让编程更加靠近人类思维。当多个类存在相同的属性（变量）和方法时，可以从这些类中**抽象出父类**，在父类中定义**相同的属性和方法**，所有的**子类不需要重新定义这些属性和方法**，只需要通过extends关键字来声明继承父类即可。

在子类中也可以重写父类的方法，这样子类在调用该方法时执行的是**重写后的方法**。

#### 2.2.继承的好处

1. 代码的复用性提高了
2. 代码的扩展性和维护性提高了

#### 2.3.子类对象实例化过程

1.从**结果**上来看： 继承性，子类继承父类以后就获取了父类中声明的属性或方法，创建子类对象后，在堆空间中就会加载所有父类中声明的属性。

2.从**过程**上来看： 当通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了`java.lang.Object`类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类的结构，子类对象才可以考虑进行调用。

### 3.多态

#### 3.1.多态基本介绍

一个方法或者对象具有多种形态（多态是建立在封装和继承的基础之上的）；父类的引用指向子类的对象；允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。

#### 3.2.多态的具体体现

1.方法的多态

重写和重载

- `重载`在方法调用之前，编译器就确定了要调用的具体的方法，称为`静态绑定`
- 对于`多态`而言，只有等到方法调用的那一刻解释运行器才会确定要调用的具体方法，称为`动态绑定`

#### 3.3.对象的多态（多态的核心）

1. 一个对象的**编译类型**和**运行类型**可以不一致
2. 在编译期只能调用父类中声明的方法，运行期实际执行的是子类中重写的方法
3. **编译类型**是定义对象时就确定的，**不能改变**
4. **运行类型是可以变化的**

对象的多态在使用时需注意：

- 前提：两个对象存在继承关系
- 本质：父类的引用指向了子类的对象
- `虚拟方法调用`：向上转型后调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法，此时父类的方法叫做`虚拟方法`
- 向上转型后内存中实际是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，不能使用子类的特有成员（可以使用`强制转换`进行向下转型）
- **动态绑定机制** ：
  - 当调用对象方法的时候，该方法会和该对象的运行类型绑定
  - 当调用对象属性的时候，没有绑定，哪里声明，哪里使用（看编译类型）

#### 3.4.对象的多态的应用

1.多态数组

数组的定义类型为父类类型，里面保存的实际类型为子类类型

2.多态参数

方法定义的形参类型为父类1类型，实参类型允许为子类类型

## c++ 底层

https://zhuanlan.zhihu.com/p/454306613
