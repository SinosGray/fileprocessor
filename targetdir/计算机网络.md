---
categories:
- cs
date: 2020-09-12 16:48:30
password: network
tags:
- org
- '255'
- wiki
- ethernet
- wikipedia
title: 计算机网络
---

><计算机网络自顶向下方法>(英文版) 英文缩写和词汇汇总
>
>学会了缩写就学会了计算机网络 ----赛诺

<!--more-->

# 网络基本功

## 报文头

### http

**request 报文**

```http
GET /dir/page.html HTTP/1.1
HOST: www.xxx.com
Connection: close
User-agent: Mozilla/5.0

(data data data)
```

**response 报文**

```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6811
Content-Type: text/html

(data data data)
```

### tcp

tcp 链接由四个值确定唯一链接:

src ip, src port, des ip, des port

![截屏2021-12-07 下午1.30.42](https://tva1.sinaimg.cn/large/008i3skNgy1gx57ht945tj30ls0mcmyh.jpg)

### udp

![截屏2021-12-07 下午1.30.09](https://tva1.sinaimg.cn/large/008i3skNgy1gx57h9iltmj30cu0aiaad.jpg)

### ip

![截屏2022-09-28 22.27.41](https://tva1.sinaimg.cn/large/e6c9d24ely1h6nbym7o2zj20kw0gqt9v.jpg)



### 以太网帧

![截屏2022-11-14 12.15.34](https://tva1.sinaimg.cn/large/008vxvgGly1h84j96ue7rj30m603mt8p.jpg)



## 交换机

### 交换机 mac 表

内容: mac 地址 --- 端口

学习: 根据来源消息学习 设备来自于哪个端口, 更新 mac 表

应用: 根据目的地址发送到目的端口

无记录: 泛洪(flooding)

### 转发方式

- 存储转发
  - 有差错控制(frame check sequence FCS)
  - 自动缓存: 输入端口和输出端口速率不一致时
- 直通交换
  - 读取帧头后马上转发
  - 无效帧会被转发
  - 无碎片转发: 直通的一种, 检查帧是否>64byte, 否则丢弃

## vlan

每一个 vlan 相当于独立的三层网络(交换机中的不同 vlan 相当于一堵三层墙)

因此，192.168.1.0上的节点试图与192.168.2.0上的节点通信时，**不同VLAN通信必须通过路由器，即使所有设备都连接到同一交换机。**二层单播，多播和广播数据只会在同一VLAN内转发及泛洪，因此VLAN 1产生的数据不会为VLAN 2节点所见。只有交换机能看得到VLAN，节点和路由器都感觉不到VLAN的存在。

“**VLAN Trunk**允许VLAN数据流在交换机间传输，所以设备在同一VLAN，但连接到不同交换机，能够不通过路由器来进行通信。”“缺省情况下，所有端口都称为接入端口。当一个端口用于交换机间互连传输VLAN信息时，这种端口模式改变为trunk，”

![截屏2022-11-14 15.06.20](https://tva1.sinaimg.cn/large/008vxvgGly1h84o6r9svbj311e0tmn1j.jpg)

## 路由

PC1:

“PC 1发送报文给PC 2时，首先必须确定目的IPv4地址是否位于同一网络。**PC 1通过将自己的IPv4地址与子网掩码做与操作，来判断PC 1所属的网段。接下来，PC 1对目的IPv4地址与PC 1的子网掩码做同样的与操作。**如果目的网络地址与PC 1网络相同，则PC 1不使用默认网关，而是在ARP缓存中查找目的IPv4地址的设备MAC地址。如果MAC地址不在缓存中，则PC 1产生一个ARP请求来获取地址并将报文发给目的地址。如果目的网络地址位于另一网络，则PC 1将报文转发至默认网关。”

“R1从PC 1接收到以太网帧后执行以下步骤：
1. R1检查目的MAC地址，与接收端口FastEthernet 0/0相匹配，因此，将帧复制到buffer。
2. R1识别以太网类型为0x800，意味着以太网帧的数据部分包含IPv4报文。
3. R1解封装该以太网帧。
4. 由于目的IPv4地址与R1直连的任何网络都不相符，R1在路由表中查找包含该目的IPv4地址主机的网络地址。本例中，路由表中有192.168.4.0/24网络的路由。目的IPv4地址为192.168.4.10，即该网络上的主机IPv4地址。

**R1找到192.168.4.0/24路由的下一条IPv4地址为192.168.2.2以及输出端口FastEthernet 0/1**，这意味着IPv4报文封装到一个新的以太网帧中，目标MAC地址是下一跳路由器的MAC地址。

“由于下一个接口是在以太网上，所以R1必须用ARP解析出下一跳IPv4地址的MAC地址。
1. R1在ARP cache中查找下一跳IPv4地址192.168.2.2。如果表项不在ARP cache中，R1会从FastEthernet 0/1 接口发送ARP请求，R2会返回ARP响应。R1之后在ARP cache中更新192.168.2.2的MAC地址。
2. IPv4报文封装到新的以太网帧中并从R1的FastEthernet 0/1 接口转发出去。

到达目的地：

当帧到达R3时执行以下步骤：

1. R3将数据链路帧复制到它的buffer。
2. R3解封装该数据链路帧。
3. R3在路由表中查找该目的IPv4地址。R3路由表中有直接连接到该网络的路由。这表示报文可直接发送到目的设备而无需发送至路由器。”

“由于输出接口是一个直连以太网，所以R3必须用ARP解析出目的IPv4地址的MAC地址。
1. R3在它的ARP cache中查找目的IPv4地址，如果此ARP cache中没有此表项，R3会从FastEthernet 0/0 接口发送ARP请求。PC 2回复ARP响应告知它的MAC地址。R3之后在ARP cache中更新192.168.4.10的MAC地址。
2. IPv4报文封装到新的以太网帧中并从R3的FastEthernet 0/0 接口发出。
3. 当PC 2接收到该帧，检查帧的目的MAC地址，与网卡接收端口的MAC地址相匹配，PC 2于是将帧的剩余部分复制到自己的buffer。
4. PC 2识别到以太网类型为0x800，也就是帧的数据部分包含IPv4报文。
5. PC 2解封装以太网帧，将IPv4报文传递给操作系统的[…]”

路由表的内容

- 直连路由
- 动态路由
- 静态路由(协议

### 静态路由 动态路由

初始状态下, 路由表中只有直连路由

静态路由: 管理员手工配置

动态路由: 

1. 路由器在端口发送和接收路由消息。

2. 路由器与其他使用相同路由协议的路由器共享路由信息。
3. 路由器交换路由信息来学习远端网络。
4. 当路由器检测到拓扑变化时，路由协议将这一变化通知其他路由器。”

动态路由协议?

## 链路聚合

![截屏2022-11-15 20.36.14](https://tva1.sinaimg.cn/large/008vxvgGly1h863cipq6gj30ss0c0dgt.jpg)

## 子网

![截屏2022-11-15 20.42.44](https://tva1.sinaimg.cn/large/008vxvgGly1h863j44fvmj30su086t95.jpg)

## tcp滑动窗口

“目标设备不会特别列出它已经确认的字节，因为这会导致效率低下。目标设备会发送自上一次成功接收后的最长字节数。”

超时重传: “每一次发送一个片段，就开启一个重传计时器。”

计时器的值: 

累积确认: “现在，让我们进一步假设传输过程中片段3丢失了，但片段4被接收到了。客户端将**片段4保存在接收buffer**中，但是不需要确认，因为TCP是累积确认机制——确认片段4表示片段3也接收到了，但实际上并没有。因此，客户端需要等待片段3。实际上，服务器端片段3的重传计时器会超时，服务器之后重传片段3。之后客户端收到，然后发送片段3和4的确认信息给服务器。”

选择重传(SACK ): tcp 可以"打开"选择重传选项.
“例如，在4个片段的情况下，如果客户端接收到片段4而没有接收到片段3，当它发回确认号为201（片段1和片段2）的确认信息，其中包含一个SACK选项指明：“已接收到字节361至500，但尚未确认”。如果片段4在片段1和2之后到达，上述信息也可以通过第二个确认片段来完成。**服务器确认片段4的字节范围，并为片段4打开SACK位**。当片段3重传时，服务器看到片段4的SACK位为1，就不会对其重传。
在片段3重传之后，片段4的SACK位被清除。这是为了防止客户端出于某种原因改变片段4已接收的想法。客户端应当发送确认号为501或更高的确认信息，正式确认片段3和4接收到。如果这一情况没有发生，服务器必须接收到片段4的另一条选择确认信息才能将它的SACK位打开，否则，在片段3重传时或计时器超时的情况下回对其自动重传

### 流量控制

“一段时间过后，服务器接收到140字节并将它们放在缓存中。现在，理想的情况下，140字节进入缓存，确认之后立刻从缓存移出。也就是说，缓存有足够的大小来容纳客户端发送的所有数据。缓存的空闲空间维持在360字节，因此告知客户端窗口大小保持不变。
**只要服务器处理速度和数据进入速度相同，窗口大小就会保持在360字节。**客户端在接收到140字节的确认信息以及窗口大小保持不变的信息之后，将360字节窗口向右移动140字节。由于现在未确认字节数为0，因此客户端又可以发送360字节数据。对应于之前可用窗口的220字节，加上刚刚确认的140字节数据。
“然而，现实中服务器可能需要处理数十，数百乃至数千个TCP连接。TCP可能无法立刻处理数据，或应用应用程序本身无法接收140字节数据。任何一种情况下，**服务器TCP都无法立刻将140字节从缓存中移出。这时，除了发回确认信息给客户端以外，服务器会想要告知客户端更改窗口大小，以表示缓存已经被部分写入了。**
**假设我们接收到140字节，但只能发送40字节给应用程序，缓存中剩下100字节。当发送140字节的确认信息，服务器将发送窗口缩小100字节，至260字节。**当客户端从服务器接收到这一片段，它将会看到140字节的确认信息并将窗口向右滑动140字节。在滑动过程中，将大小缩减至260字节。可以认为将窗口左端滑动140字节，但右端仅滑动40字节。

## linux 网络配置

### 将一条设备添加到本地网络

- 指定唯一的IP地址与主机名。

  “由于/etc/hosts仅包括本地映射而且必须维护在每一台客户端设备，所以最好保存那些需要在启动时映射的信息（即：主机本身，默认网关，以及域名服务器）。


- 确保启动时正确配置网络接口。

- 创建默认路由。

- 指定DNS域名服务器以使设备能够连接到网络其他部分。”





















































# 总结

## sha Secure Hash Algorithm

**安全散列算法**（英语：Secure Hash Algorithm，缩写为SHA）是一个[密码散列函数](https://zh.wikipedia.org/wiki/密碼雜湊函數)家族，是[FIPS](https://zh.wikipedia.org/wiki/联邦资料处理标准)所认证的安全[散列算法](https://zh.wikipedia.org/wiki/雜湊函數)。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。

## md5

**MD5消息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的[密码散列函数](https://zh.wikipedia.org/wiki/密碼雜湊函數)，可以产生出一个128位（16个字符(BYTES)）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家[罗纳德·李维斯特](https://zh.wikipedia.org/wiki/罗纳德·李维斯特)（Ronald Linn Rivest）设计，于1992年公开，用以取代[MD4](https://zh.wikipedia.org/wiki/MD4)算法。这套算法的程序在 [RFC 1321](https://tools.ietf.org/html/rfc1321) 中被加以规范。

将[数据](https://zh.wikipedia.org/wiki/数据)（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。

1996年后被证实存在弱点，可以被加以[破解](https://zh.wikipedia.org/wiki/破解)，对于需要高度安全性的资料，专家一般建议改用其他算法，如[SHA-2](https://zh.wikipedia.org/wiki/SHA-2)。2004年，证实MD5算法无法防止[碰撞攻击](https://zh.wikipedia.org/w/index.php?title=碰撞攻击&action=edit&redlink=1)，因此不适用于安全性认证，如[SSL](https://zh.wikipedia.org/wiki/SSL)[公开密钥认证](https://zh.wikipedia.org/wiki/公開金鑰認證)或是[数字签名](https://zh.wikipedia.org/wiki/數位簽章)等用途。

### 步骤

We begin by supposing that we have a **b-bit message as input**, and that we wish to find its message digest. Here b is an arbitrary nonnegative integer; b may be zero, it need not be a multiple of eight, and it may be arbitrarily large. We imagine the bits of the message written down as follows:

```
   m_0 m_1 ... m_{b-1}
```

The following five steps are performed to compute the message digest of the message.

**Step 1. Append Padding Bits**

   The message is "padded" (extended) so that its length (in bits) is congruent to **448**, modulo 512. That is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits long. Padding is always performed, even if the length of the message is already congruent to 448, modulo 512.

   Padding is performed as follows: a single "1" bit is appended to the message, and then "0" bits are appended so that the length in bits of the padded message becomes congruent to 448, modulo 512. In all, at least one bit and at most 512 bits are appended.

**Step 2. Append Length**

   A 64-bit representation of b (**the length of the message before the padding bits were added**) is appended to the result of the previous step. In the unlikely event that b is greater than 2^64, then only the low-order 64 bits of b are used. (These bits are appended as two 32-bit words and appended low-order word first in accordance with the previous conventions.)

   At this point the resulting message (after padding with bits and with b) has a length that is an exact multiple of 512 bits. Equivalently, this message has a length that is an exact multiple of 16 (32-bit) words. Let M[0 ... N-1] denote the words of the resulting message, where N is a multiple of 16.

**Step 3. Initialize MD Buffer**

   A four-word buffer (A,B,C,D) is used to compute the message digest. Here each of A, B, C, D is a 32-bit register. These registers are initialized to the following values in hexadecimal, low-order bytes first):


          word A: 01 23 45 67
          word B: 89 ab cd ef
          word C: fe dc ba 98
          word D: 76 54 32 10

**Step 4. Process Message in 16-Word Blocks**

   We first define four auxiliary functions that each take as input three 32-bit words and produce as output one 32-bit word.

          F(X,Y,Z) = XY v not(X) Z
          G(X,Y,Z) = XZ v Y not(Z)
          H(X,Y,Z) = X xor Y xor Z
          I(X,Y,Z) = Y xor (X v not(Z))

   In each bit position F acts as a conditional: if X then Y else Z. The function F could have been defined using + instead of v since XY and not(X)Z will never have 1's in the same bit position.) It is interesting to note that if the bits of X, Y, and Z are independent and unbiased, the each bit of F(X,Y,Z) will be independent and unbiased.

   The functions G, H, and I are similar to the function F, in that they act in "bitwise parallel" to produce their output from the bits of X, Y, and Z, in such a manner that if the corresponding bits of X, Y, and Z are independent and unbiased, then each bit of G(X,Y,Z), H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased. Note that the function H is the bit-wise "xor" or "parity" function of its inputs.

   This step uses a 64-element table T[1 ... 64] constructed from the sine function. Let T[i] denote the i-th element of the table, which is equal to the integer part of 4294967296 times abs(sin(i)), where i is in radians. The elements of the table are given in the appendix.

   Do the following:

   

```shell
 /* Process each 16-word block. */
 For i = 0 to N/16-1 do
 /* Copy block i into X. */
   For j = 0 to 15 do
     Set X[j] to M[i*16+j].
   end /* of loop on j */

   /* Save A as AA, B as BB, C as CC, and D as DD. */
   AA = A
   BB = B
   CC = C
   DD = D

   /* Round 1. */
   /* Let [abcd k s i] denote the operation
        a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
   /* Do the following 16 operations. */
   [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
   [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
   [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
   [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]

   /* Round 2. */
   /* Let [abcd k s i] denote the operation
        a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
   /* Do the following 16 operations. */
   [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
   [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
   [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
   [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]

   /* Round 3. */
   /* Let [abcd k s t] denote the operation
        a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
   /* Do the following 16 operations. */
   [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
   [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
   [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
   [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]

   /* Round 4. */
   /* Let [abcd k s t] denote the operation
        a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
   /* Do the following 16 operations. */
   [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
   [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
   [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
   [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]

   /* Then perform the following additions. (That is increment each
      of the four registers by the value it had before this block
      was started.) */
   A = A + AA
   B = B + BB
   C = C + CC
   D = D + DD
end /* of loop on i */
```

**Step 5. Output**

   The message digest produced as output is A, B, C, D. That is, we begin with the low-order byte of A, and end with the high-order byte of D.

   This completes the description of MD5. A reference implementation in C is given in the appendix.

**Summary**

The MD5 message-digest algorithm is simple to implement, and provides a "fingerprint" or message digest of a message of arbitrary length. It is conjectured that the difficulty of coming up with two messages having the same message digest is on the order of 2^64 operations,
and that the difficulty of coming up with any message having a given message digest is on the order of 2^128 operations. The MD5 algorithm has been carefully scrutinized for weaknesses. It is, however, a relatively new algorithm and further security analysis is of course justified, as is t he case with any new proposal of this sort.

## base64

**Base64**（基底64）是一种基于64个可打印字符来表示[二进制数据](https://zh.wikipedia.org/wiki/二进制)的表示方法。由于log~2~64 = 6，所以每6个[比特](https://zh.wikipedia.org/wiki/位元)为一个单元，对应某个可打印字符。3个[字节](https://zh.wikipedia.org/wiki/字节)相当于24个比特，对应于4个Base64单元，在Base64中的可打印字符包括[字母](https://zh.wikipedia.org/wiki/拉丁字母)`A-Z`、`a-z`、[数字](https://zh.wikipedia.org/wiki/数字)`0-9`，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。

Base64常用于在通常处理文本[数据](https://zh.wikipedia.org/wiki/数据)的场合，表示、传输、存储一些二进制数据. 

如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用**0字节值在末尾补足**，使其能够被3整除，然后再进行Base64的编码。在编码后的Base64文本后**加上一个或两个`=`号**，代表补足的字节数。也就是说，当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。

| 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  A   |  16  |  Q   |  32  |  g   |  48  |  w   |
|  1   |  B   |  17  |  R   |  33  |  h   |  49  |  x   |
|  2   |  C   |  18  |  S   |  34  |  i   |  50  |  y   |
|  3   |  D   |  19  |  T   |  35  |  j   |  51  |  z   |
|  4   |  E   |  20  |  U   |  36  |  k   |  52  |  0   |
|  5   |  F   |  21  |  V   |  37  |  l   |  53  |  1   |
|  6   |  G   |  22  |  W   |  38  |  m   |  54  |  2   |
|  7   |  H   |  23  |  X   |  39  |  n   |  55  |  3   |
|  8   |  I   |  24  |  Y   |  40  |  o   |  56  |  4   |
|  9   |  J   |  25  |  Z   |  41  |  p   |  57  |  5   |
|  10  |  K   |  26  |  a   |  42  |  q   |  58  |  6   |
|  11  |  L   |  27  |  b   |  43  |  r   |  59  |  7   |
|  12  |  M   |  28  |  c   |  44  |  s   |  60  |  8   |
|  13  |  N   |  29  |  d   |  45  |  t   |  61  |  9   |
|  14  |  O   |  30  |  e   |  46  |  u   |  62  |  +   |
|  15  |  P   |  31  |  f   |  47  |  v   |  63  |  /   |

## [RSA](https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

> （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
>
> （2）甲方获取乙方的公钥，然后用它对信息加密。
>
> （3）乙方得到加密后的信息，用私钥解密。

> 随机质数 p, q, n=pq, 1< e < φ(n) e与φ(n) 互质, ed ≡ 1 (mod φ(n))
>
> 公钥(n, e)
>
> 私钥(n, d)
>
> ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。
>
> φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。
>
> n=pq。只有将n因数分解，才能算出p和q。

### **一、一点历史**

1976年以前，由于加密和解密使用同样规则（简称"密钥"），这被称为["对称加密算法"](https://zh.wikipedia.org/zh-cn/对等加密)（Symmetric-key algorithm）。

> 甲发乙收

这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。

1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为["Diffie-Hellman密钥交换算法"](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange)。

这种新的加密模式被称为"非对称加密算法"。

**如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。**

1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做[RSA算法](https://zh.wikipedia.org/zh-cn/RSA加密算法)。从那时直到现在，**RSA算法一直是最广为使用的"非对称加密算法"**。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。

这种算法非常[可靠](https://en.wikipedia.org/wiki/RSA_Factoring_Challenge)，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。

### **二、互质关系**

如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是[互质关系](https://zh.wikipedia.org/zh-cn/互素)（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。

关于互质关系，不难得到以下结论：

> 　　1. 任意两个质数构成互质关系，比如13和61。
>
> 　　2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。
>
> 　　3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。
>
> 　　4. 1和任意一个自然数是都是互质关系，比如1和99。
>
> 　　5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。
>
> 　　6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。

### **三、欧拉函数**

请思考以下问题：

> 　　任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成**互质关系**？（比如，在1到8之中，有多少个数与8构成互质关系？）

计算这个值的方法就叫做[欧拉函数](https://zh.wikipedia.org/wiki/欧拉函数)，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。

φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。

**第一种情况 n=1** 

如果n=1，则 **φ(1) = 1** 。因为1与任何数（包括自身）都构成互质关系。

**第二种情况 n 为质数**

如果n是质数，则 **φ(n)=n-1** 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。

**第三种情况 n = p^k^**

如果n是质数的某一个次方，即 n = p^k^ (p为质数，k为大于等于1的整数)，则 **φ(p^k^)=p^k^ - p^k-1^ = p^k^(1 - 1/p)** 

比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。

这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)^个，即1×p、2×p、3×p、...、p^(k-1)^×p，把它们去除，剩下的就是与n互质的数。

**第四种情况 n = p1 × p2**

如果n可以分解成两个互质的整数之积，则

**φ(n) = φ(p1p2) = φ(p1)φ(p2)**

即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。

这一条的证明要用到["中国剩余定理"](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)，这里就不展开了，只简单说一下思路：如果a与p1互质(a<p1)，b与p2互质(b<p2)，c与p1p2互质(c<p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。

**第五种情况 n = p~1~^k1^ p~2~^k2^ ... p~r~^kr^**

因为任意一个大于1的正整数，都可以写成一系列质数的积。

**φ(n) = φ(p1p2 ... pr) **
**= φ(p1)φ(p2)...φ(pr) **
**= p~1~^k1^ p~2~^k2^ ... p~r~^kr^(1-1/p1)(1-1/p2)...(1-1/pr)**
**= n(1-1/p1)(1-1/p2)...(1-1/pr)** 

### **四、欧拉定理**

欧拉函数的用处，在于[欧拉定理](https://zh.wikipedia.org/wiki/欧拉定理_(数论))。"欧拉定理"指的是：

> 如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：
>
> **a^φ(n)^ ≡ 1(mod n)**

也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。

欧拉定理有一个特殊情况。

> 假设正整数a与**质数p**互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成
>
> **a^p-1^ ≡ 1(mod p)**

这就是著名的[费马小定理](https://zh.wikipedia.org/wiki/费马小定理)。它是欧拉定理的特例。

欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。

### **五、模反元素**

还剩下最后一个概念：

> 如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。
>
> **ab ≡ 1(mod n)**
>
> 这时，b就叫做a的["模反元素"](https://zh.wikipedia.org/wiki/模反元素)。

比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {...,-18,-7,4,15,26,...}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。

欧拉定理可以用来证明模反元素必然存在。

**a^p-1^  = a a^φ(n)-1^ ≡ 1(mod n)**

可以看到，a的 φ(n)-1 次方，就是a的模反元素。



### **六、密钥生成的步骤**

我们通过一个例子，来理解RSA算法。假设[爱丽丝](https://zh.wikipedia.org/wiki/爱丽丝与鲍伯)要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？

**第一步，随机选择两个不相等的质数p和q。**

爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）

**第二步，计算p和q的乘积n。**

爱丽丝就把61和53相乘。

> 　　n = 61×53 = 3233

**n的长度就是密钥长度**。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

**第三步，计算n的欧拉函数φ(n)。**

根据公式：

> 　　φ(n) = (p-1)(q-1)

爱丽丝算出φ(3233)等于60×52，即3120。

**第四步，随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质。**

爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）

**第五步，计算e对于φ(n)的模反元素d。**

所谓["模反元素"](https://zh.wikipedia.org/wiki/模反元素)就是指有一个整数d，可以使得ed被φ(n)除的余数为1。

> 　　ed ≡ 1 (mod φ(n))

这个式子等价于

> 　　ed - 1 = kφ(n)

于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。

> 　　ex + φ(n)y = 1

已知 e=17, φ(n)=3120，

> 　　17x + 3120y = 1

这个方程可以用["扩展欧几里得算法"](https://zh.wikipedia.org/wiki/扩展欧几里得算法)求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。

至此所有计算完成。

**第六步，将n和e封装成公钥，n和d封装成私钥。**

> 随机质数 p, q, n=pq, 1< e < φ(n) e与φ(n) 互质, ed ≡ 1 (mod φ(n))

在爱丽丝的例子中，n=3233，e=17，d=2753，
所以公钥就是 (n, e)(3233,17)，
私钥就是 (n, d)（3233, 2753）。

实际应用中，公钥和私钥的数据都采用[ASN.1](https://zh.wikipedia.org/zh-cn/ASN.1)格式表达（[实例](https://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2)）。

### **七、RSA算法的可靠性**

回顾上面的密钥生成步骤，一共出现六个数字：

> 　　p
> 　　q
> 　　n
> 　　φ(n)
> 　　e
> 　　d

这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。

**那么，有无可能在已知n和e的情况下，推导出d？**

> 　　（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。
>
> 　　（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。
>
> 　　（3）n=pq。只有将n因数分解，才能算出p和q。

**结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。**

> 　　"对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。
>
> 　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。
>
> 　　只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"

事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。

### **八、加密和解密**

有了公钥和密钥，就能进行加密和解密了。

**（1）加密要用公钥 (n,e)**

假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。

所谓"加密"，就是算出下式的c：

> 　　**me ≡ c (mod n)**

爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：

> 　　6517 ≡ 2790 (mod 3233)

于是，c等于2790，鲍勃就把2790发给了爱丽丝。

**（2）解密要用私钥(n,d)**

爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：

> 　　**cd ≡ m (mod n)**

也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出

> 　　27902753 ≡ 65 (mod 3233)

因此，爱丽丝知道了鲍勃加密前的原文就是65。

至此，"加密--解密"的整个过程全部完成。

我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。

你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种"对称性加密算法"（比如[DES](https://zh.wikipedia.org/wiki/资料加密标准)），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。

### **九、私钥解密的证明**

最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：

> 　　cd ≡ m (mod n)

因为，根据加密规则

> 　　ｍe ≡ c (mod n)

于是，c可以写成下面的形式：

> 　　c = me - kn

将c代入要我们要证明的那个解密规则：

> 　　(me - kn)d ≡ m (mod n)

它等同于求证

> 　　med ≡ m (mod n)

由于

> 　　ed ≡ 1 (mod φ(n))

所以

> 　　ed = hφ(n)+1

将ed代入：

> 　　mhφ(n)+1 ≡ m (mod n)

接下来，分成两种情况证明上面这个式子。

**（1）m与n互质。**

根据欧拉定理，此时

> 　　mφ(n) ≡ 1 (mod n)

得到

> 　　(mφ(n))h × m ≡ m (mod n)

原式得到证明。

**（2）m与n不是互质关系。**

此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。

以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：

> 　　(kp)q-1 ≡ 1 (mod q)

进一步得到

> 　　[(kp)q-1]h(p-1) × kp ≡ kp (mod q)

即

> 　　(kp)ed ≡ kp (mod q)

将它改写成下面的等式

> 　　(kp)ed = tq + kp

这时t必然能被p整除，即 t=t'p

> 　　(kp)ed = t'pq + kp

因为 m=kp，n=pq，所以

> 　　med ≡ m (mod n)

原式得到证明。



## Public-key cryptography

**Public-key cryptography**, or **asymmetric cryptography**, is a cryptographic system that uses pairs of [keys](http://en.volupedia.org/wiki/Cryptographic_key). Each pair consists of a *public key* (which may be known to others) and a *private key* (which may not be known by anyone except the owner). 

**In such a system, any person can [encrypt](http://en.volupedia.org/wiki/Encryption) a message using the intended receiver's *public key*, but that encrypted message can only be decrypted with the receiver's *private key*.** This allows, for instance, a server program to generate a cryptographic key intended for a suitable [symmetric-key cryptography](http://en.volupedia.org/wiki/Symmetric-key_algorithm), then to use a client's openly-shared *public key* to encrypt that newly generated *symmetric key*. The server can then **send this encrypted symmetric key** over an insecure channel to the client; only the client can decrypt it using the client's private key (which pairs with the public key used by the server to encrypt the message). With the client and server both having the same symmetric key, they can safely use symmetric key encryption (likely much faster) to communicate over otherwise-insecure channels. This scheme has the advantage of not having to manually pre-share symmetric keys (a fundamentally difficult problem) while gaining the higher data throughput advantage of [symmetric-key cryptography](http://en.volupedia.org/wiki/Symmetric-key_algorithm).

## Secure Shell Protocol

The **Secure Shell Protocol** (**SSH**) is a [cryptographic](http://en.volupedia.org/wiki/Cryptography) [network protocol](http://en.volupedia.org/wiki/Network_protocol) for operating [network services](http://en.volupedia.org/wiki/Network_service) securely over an unsecured network.[[2\]](http://en.volupedia.org/wiki/Secure_Shell#cite_note-rfc4251-2) Its most notable applications are **remote [login](http://en.volupedia.org/wiki/Login) and [command-line](http://en.volupedia.org/wiki/Command-line_interface) execution.**

#### Definition[[edit](http://en.volupedia.org/w/index.php?title=Secure_Shell&action=edit&section=1)]

SSH uses [public-key cryptography](http://en.volupedia.org/wiki/Public-key_cryptography) to [authenticate](http://en.volupedia.org/wiki/Authentication)(进行身份验证) the remote computer and allow it to authenticate the user, if necessary.[[3\]](http://en.volupedia.org/wiki/Secure_Shell#cite_note-rfc4252-3)

SSH may be used in several methodologies. In the simplest manner, both ends of a communication channel use automatically generated **public-private key pairs** to encrypt a network connection, and then use a [password](http://en.volupedia.org/wiki/Password) to authenticate the user.

## [数字签名](https://www.zhihu.com/question/24294477/answer/74783418)

![image-20220315205645711](https://tva1.sinaimg.cn/large/e6c9d24ely1h0av432ionj21ks0h2jtk.jpg)

### 内容

前提: 非对称加密, hash 算法校验
首先，有一个权威的证书签发机构，称为CA——全球就那么几个公司比较权威啦，这个机构，先用RSA产生一对公私钥。
然后用自己的私钥对自己的公钥进行签名，生成所谓的数字证书。
这个过程大概是这样的：

先生成一个文件，文件内容大概是这样的：

> 公钥内容
> 签发者ID----谁签发的证书
> Subject----也就是这个证书签发给谁。这里subject和签发者ID相同。
> [有效期](https://www.zhihu.com/search?q=有效期&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A74783418})
> 其他信息

以上内容都是明文。我们称为**内容P**。
然后使用hash算法，对内容P进行hash计算，得到一个**[hash值](https://www.zhihu.com/search?q=hash值&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A74783418})H**。
然后使用签发机构的**私钥**对H进行RSA加密，得到**签名信息S**。**这个步骤称为签名，就是用*私钥*对某公开内容的hash值进行加密。**
然后将P，S连成一个文件，这个文件就是所谓的数字证书了。

现在假设某人得到了这个证书，如何确认这个证书属于谁的呢？
我们用同样的hash算法对P进行hash计算，得到一个hash值H1.
P里有公钥，签发者ID，Subject，有效期，及其他信息。**我们用*公钥*解密S，得到了一个值H’。**
这个H‘，正常情况，或者说期望正常的话，应该就是制作数字证书的时候，用私钥对S加密的H。是否真如期望一样呢？比较一番就知道了。
现在对比H’和H1是否相等，如果相等，那么就证明这个证书是有签发者签发给subject的证书，就是符合期望了，也就是正常情况。否则就说明：1.内容P被篡改过，或者2.证书不是由CA签发的。
这个是对自签发证书的验证过程。需要说明的是，这种自签发证书的验证不常使用，但如何验证证书的原理类似。

### 权威 CA

既然自己可以给自己签发证书，那黑客宣称自己是某著名CA，然后给自己签发一个证书。那验证者如何来验证这个证书是黑客自己的呢还是那个著名的CA呢？
如果仅仅按照上文所说的自签发证书验证过程来看，是无法确认身份的。
这个问题，就是CA存在的意义了。

所谓**全球权威的CA**，就那么几个公司，这几个公司的证书，被各软件厂商设置成“可信任的**根**证书”了。所谓的根证书，是指这个证书是受信任的起始点，随后可以用这个证书来证明其他的证书。

现在知道了，自签发的数字证书，要被各软件信任，是不容易的。一旦CA的根证书存在用户的系统了，就可以用这个根证书来验证其他证书了。并用被验证过的证书来认证身份。






## [Secure Sockets Layer / Transport Layer Security](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0atgdvmb8j21000u077l.jpg" alt="image-20220315195923413" style="zoom:50%;" />

从上面的过程可以看到，TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法（TLS 的传输会使用 MAC(message authentication code) 进行完整性检查）。

**?客户端生成秘钥**

### **一、作用**

不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

（1） **窃听风险**（eavesdropping）：第三方可以获知通信内容。

（2） **篡改风险**（tampering）：第三方可以修改通信内容。

（3） **冒充风险**（pretending）：第三方可以冒充他人身份参与通信。

SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

（1） 所有信息都是**加密传播**，第三方无法窃听。

（2） 具有**校验机制**，一旦被篡改，通信双方会立刻发现。

（3） 配备**身份证书**，防止身份被冒充。

### **二、历史**

目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。

TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。

### **三、基本的运行过程**

SSL/TLS协议的基本思路是采用[公钥加密法](https://en.wikipedia.org/wiki/Public-key_cryptography)，也就是说，**客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。**

但是，这里有两个问题。

**（1）如何保证公钥不被篡改？**

> 解决方法：将公钥放在[数字证书](https://en.wikipedia.org/wiki/Digital_certificate)中。只要证书是可信的，公钥就是可信的。

**（2）公钥加密计算量太大，如何减少耗用的时间？**

> 解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，**而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间**。

因此，SSL/TLS协议的基本过程是这样的：

> （1） 客户端向服务器端索要并验证公钥。
>
> （2） 双方协商生成"对话密钥"。
>
> （3） 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

### **四、握手阶段的详细过程**

"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是**明文**的。

#### **4.1 客户端发出请求（ClientHello）**

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。

在这一步，客户端主要向服务器提供以下信息。

> （1） 支持的协议版本，比如TLS 1.0版。
>
> （2） 一个客户端生成的**随机数**，稍后用于生成"**对话密钥**"。
>
> （3） 支持的加密方法，比如RSA公钥加密。
>
> （4） 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。

对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个[Server Name Indication扩展](https://tools.ietf.org/html/rfc4366)，允许客户端向服务器提供它所请求的域名。

#### **4.2 服务器回应（SeverHello）**

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

> （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
>
> （2） 一个服务器生成的**随机数**，稍后用于生成"**对话密钥**"。
>
> （3） 确认使用的加密方法，比如RSA公钥加密。
>
> （4） **服务器证书**。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

#### **4.3 客户端回应**

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，**客户端就会从证书中取出服务器的公钥**。然后，向服务器发送下面三项信息。

> （1） 一个**随机数**。该随机数用服务器公钥加密，防止被窃听。
>
> （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
>
> （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，[dog250](http://blog.csdn.net/dog250/article/details/5717162)解释得很好：

> "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
>
> **对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。**
>
> pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

#### **4.4 服务器的最后回应**

服务器收到客户端的第三个随机数 pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

> （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
>
> （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。







## 科学上网

### Virtual Private Network

#### what is V皮N

In very simple terms, a VPN **connects** your PC, smartphone, or tablet to another computer (called a server) somewhere on the internet, and allows you to **browse the internet using that computer’s internet connection**. So if that server is in a different country, it will appear as if you are coming from that country, and you can potentially access things that you couldn’t normally.

They **originally** were just a way to connect business networks together securely over the internet or allow you to access a business network from home.

#### how does V皮N work

When you connect your computer (or another device, such as a smartphone or tablet) to a VPN, the computer acts as if it’s on the same local network as the VPN. **All your network traffic is sent over a secure connection to the VPN**. Because your computer behaves as if it’s on the network, this allows you to securely access local network resources even when you’re on the other side of the world. You’ll also be able to use the Internet as if you were present at the VPN’s location, which has some benefits if you’re using public Wi-Fi or want to access geo-blocked websites.

When you browse the web while connected to a VPN, your computer contacts the website through the encrypted VPN connection. **The VPN forwards the request for you and forwards the response from the website back through the secure connection**. If you’re using a USA-based VPN to access Netflix, Netflix will see your connection as coming from within the USA.

### ShadowSocks

**Shadowsocks**（简称**SS**）是一种基于[Socks5](https://zh.wikipedia.org/wiki/SOCKS#SOCK5)

> (**SOCKS**是一种[网络传输协议](https://zh.wikipedia.org/wiki/网络传输协议)，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKet Secure"的[缩写](https://zh.wikipedia.org/wiki/缩写)。当[防火墙](https://zh.wikipedia.org/wiki/防火墙_(网络))后的客户端要访问外部的服务器时，就跟SOCKS[代理服务器](https://zh.wikipedia.org/wiki/代理服务器)连接。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持[UDP](https://zh.wikipedia.org/wiki/用户数据报协议)、验证，以及[IPv6](https://zh.wikipedia.org/wiki/IPv6)。根据[OSI模型](https://zh.wikipedia.org/wiki/OSI模型)，SOCKS是[会话层](https://zh.wikipedia.org/wiki/会话层)的协议, 不提供[加密](https://zh.wikipedia.org/wiki/加密)。)

代理方式的加密传输协议，也可以指实现这个协议的各种开发包。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并创建本地代理。

采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks 不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks 代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。

**VPN**顾名思义，虚拟专网，你接入VPN就是接入了一个专有网络，那么你访问网络都是从这个专有网络的出口出去，好比你在家，你家路由器后面的网络设备是在同一个网络，而VPN则是让你的设备进入了另一个网络。同时你的IP地址也变成了由VPN分配的一个IP地址。通常是一个私网地址。你和VPN服务器之间的通信是否加密取决于连接VPN的具体方式/协议。

**Sock5代理服务器**则是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地。你没有加入任何新的网络，只是http/socks数据经过代理服务器的转发送出，并从代理服务器接收回应。你与代理服务器通信过程不会被额外处理，如果你用https，那本身就是加密的。

### ShadowSocksR

ShadowsocksR（简称SSR）是网名为breakwa11的用户发起的Shadowsocks分支，在Shadowsocks的基础上增加了一些资料混淆方式，称修复了部分安全问题并可以提高[QoS](https://zh.wikipedia.org/wiki/QoS)优先级。[[32\]](https://zh.wikipedia.org/wiki/Shadowsocks#cite_note-33)后来贡献者Librehat也为Shadowsocks补上了一些此类特性，[[33\]](https://zh.wikipedia.org/wiki/Shadowsocks#cite_note-ssr-sec-gpl-34)甚至增加了类似[Tor](https://zh.wikipedia.org/wiki/Tor)的可插拔传输层功能。[[34\]](https://zh.wikipedia.org/wiki/Shadowsocks#cite_note-35)



## [ss & v皮n](https://www.zybuluo.com/gongzhen/note/472805)

### Shadowsocks，即Sock5代理

### Shadowsocks全局模式与VPN的区别

VPN控制的是你电脑的整个网络，只要需要连接到互联网的流量都会经过vpn。

你的IP会被更换为VPN的IP。连接VPN只需要知道IP和账号密码。

Shadowsocks的全局模式，是设置你的系统代理的代理服务器，使你的所有http/socks数据经过代理服务器的转发送出。而只有支持socks5或者使用系统代理的软件才能使用Shadowsocks（一般的浏览器都是默认使用系统代理）。

经过代理服务器的IP会被更换。连接Shadowsocks需要知道IP、端口、账号密码和加密方式。但是Shadowsocks因为可以自由换端口，所以定期换端口就可以有效避免IP被封！

### Shadowsocks全局模式与PAC模式的区别

上面已经解释了Shadowsocks的全局模式，而PAC模式就是会在你连接网站的时候读取PAC文件里的规则，来确定你访问的网站有没有被墙，如果符合，那就会使用代理服务器连接网站，而PAC列表一般都是从GFWList更新的。GFWList定期会更新被墙的网站（不过一般挺慢的）。

简单地说，在全局模式下，所有网站默认走代理。而PAC模式是只有被墙的才会走代理，推荐PAC模式，如果PAC模式无法访问一些网站，就换全局模式试试，一般是因为PAC更新不及时（也可能是GFWList更新不及时）导致的。

还有，说一下Chrome不需要Proxy SwitchyOmega和Proxy SwitchySharp插件，这两个插件的作用就是，快速切换代理，判断网站需不需要使用某个代理的（ss已经有pac模式了，所以不需要这个）。如果你只用shadowsocks的话，就不需要这个插件了！

------

个人认为现在的Shadowsocks加密技术是很不错的，推荐使用Shadowsocks（IOS除外），想要做到类VPN的方式（控制整个网络）可以搭配Proxifier使用，教程看这里。

上面仅代表个人的浅层观点，目前墙针对VPN的封锁越来越严重，比较有名的OpenVPN已经被第一个集火了！而PPTP也逐渐不稳定了起来，可能今天能用，明天就不能用了。L2TP和IPSe0c目前还好，加密方式还无法被效率破解。

## DDNS dynamic DNS

DDNS的全称是动态域名服务，简单的说就是把一个IP地址映射到一个域名身上，一般大公司诸如百度这些IP都是固定的，而对个人用户来说，想有一个固定的家庭网络IP地址显然是一件不现实的事情, 这就需要DDNS了，DDNS将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，而服务器程序负责提供DNS服务并实现动态域名解析。这样我们只要在外部输入我们的域名就可以访问了，即便IP换了也是一样的。

## hosts file(wikipedia)

The [computer file](http://en.volupedia.org/wiki/Computer_file) **hosts** is an operating system file that maps [hostnames](http://en.volupedia.org/wiki/Hostname) to [IP addresses](http://en.volupedia.org/wiki/IP_address).

## **A**ddress **R**esolution **P**rotocol(wiki)

根据目的主机的IP地址，获得其[MAC地址](https://zh.wikipedia.org/wiki/MAC地址)，这个方法就是通过发送一个叫做**arp请求**的数据包 *(arp数据包也是被包含在以太网帧中的，发送时，帧头部中的目的mac地址填写为0xffffffff，表示在本地局域网上广播，这样属于该局域网的所有机器接收到一个广播帧的时候都会向协议栈递交这个帧中的数据包，这里是arp数据包)* 广播到该局域网中

而仅当某台机器的IP地址与该arp请求中的要询问的ip地址相同时，那台机器就才会向发送方返回一个arp回应数据包，这个回应包中就包含了先前要询问的机器的IP地址 + MAC地址

本地主机接收到这个回应的arp数据包后，会提取ip地址和mac地址，记录到一个叫做**arp的表**的表项中，这样就把目的主机的ip地址和mac地址对应关系记录下来了

另外，当发送主机和目的主机不在同一个[局域网](https://zh.wikipedia.org/wiki/局域网)中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过[路由](https://zh.wikipedia.org/wiki/路由)器进行ip层的转发才可以，因为路由器把这个局域网进行了链路层上的隔离*(除非进行网络层次的显示转发，否则路由器不会把一个局域网中的以太网帧自动的转发到另一个局域网或者外网中去，如果可以自动转发，可以想象有多可怕，无效的广播帧可能像洪水一样淹没整个网络，使得网络瘫痪，这也就是路由器的基本功能之一，隔离网络)*，所以此时，发送主机会把一个**网关ip地址作为目的ip地址**(这个是ip层决定的)，那么通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或**ARP代理（ARP Proxy）**。

### Advanced Research Projects Agency Network (ARPANET)

The **Advanced Research Projects Agency Network** (**ARPANET**) was the first wide-area [packet-switched network](http://en.volupedia.org/wiki/Packet-switched_network) with distributed control and one of the first networks to implement the [TCP/IP](http://en.volupedia.org/wiki/Internet_protocol_suite) protocol suite.

## one device can ping the other cannot in the same LAN

### environment

macos ios

no vpn ssr, ping `theme.typora.io`

macos hosts empty

### points

#### 



## [ethernet](https://www.cisco.com/c/en/us/solutions/enterprise-networks/what-is-ethernet.html)

> If two or more connected devices on a shared network attempt to transmit data packets at the same time, a packet collision occurs. Ethernet technology provides rules that **allow network-connected devices to talk to one another without packet collisions**.

### What Is Ethernet?

Ethernet technology provides rules that allow network-connected devices to talk to one another without talking over each other. In a verbal conversation, when two people speak at the same time, each may have difficulty understanding what the other is saying. This is amplified when, say, 10 people are talking at once. Imagine 100 or 1000 at once.

The same is true for a data network. If two or more connected devices on a shared network attempt to transmit data packets at the same time, a **packet collision** occurs. The pulses of electricity or photons that make up a packet overlap when sent at the same time over a shared copper or optical cable. This jumbles the sequence of "on" pulses and "off" voids that are sent to indicate the bits and bytes of 1s and 0s that make up a packet.

Ethernet was designed to solve the problem of packet collision. It provides network devices with a set of **rules** that essentially says: "**Make sure no one else is talking before you talk. If you hear someone talking while you're talking, stop, listen, and wait for the talking to end before you talk again.**"

Ethernet is commonly associated with connected devices in a wired LAN or WAN. Using a wired Ethernet cable, devices are connected to an [Ethernet switch](https://www.cisco.com/c/en/us/products/switches/what-is-an-ethernet-switch.html). Ethernet has the ability to use both wired and fiber cables, delivering not only data but also power, now up to 90W with UPOE+.

More formally, **Ethernet is a common name for the IEEE 802.3 standard based on the Carrier Sense Multiple Access/Collision Detection (CSMA/CD) protocol**. CSMA/CD defines when to transmit and what is to happen if a collision is detected, as well as endpoint addressing, transmission speeds, and media. Ethernet has evolved dramatically since its first application. Today it's the de facto protocol for IP-based networks.

### Where did Ethernet originate?

The concept of Ethernet has its roots in the late 1960s and the University of Hawaii's Aloha Network. Aloha was a pioneering, experimental radio-communications network connecting the Hawaiian Islands to a central time-shared computer on the main campus, in Oahu.

Aloha was often referred to as one of the first wireless packet networks. It used two radio frequencies, separating send and receive data that passed between user terminals and the main hub connected to the computer. Designed for simplicity, the network followed these rules:

- Send a packet when you're ready and wait for a receipt acknowledgement.
- If no acknowledgement occurs, resend at some random time.

As use of the network grew, it became obvious that packet collision would severely limit the capacity of the network as designed. Researching the problem for his doctoral thesis, a young computer science student, Bob Metcalfe, devised a solution. His innovation earned him not only his Harvard Ph.D. but a place in history as the inventor of Ethernet. Metcalfe's solution: **Listen before you talk.**

In 1972, Metcalfe took Ethernet from idea to fruition with the first experimental Ethernet system, created at Xerox PARC. The network had an initial speed of 2.94 Mbps and linked Xerox Altos mainframes, servers, and printers using inexpensive coaxial cable.

At the time, Ethernet competed with Token Ring, ARCnet, Fiber Distributed Data Interface (FDDI), and other proprietary protocols. It quickly rose to dominance as it was open and reliable, yet inexpensive. Today, it supports speeds from 1 Mbps to 400 Gbps and beyond.

### When was the Ethernet standard created?

Ethernet was formalized in 1983 as the IEEE 802.3 Ethernet standard. It is one of 12 in the IEEE 802 family of variable-size packet LAN standards. **IEEE 802 services and protocols focus on the physical and data link layers** of a network. In the Open Systems Interconnection (OSI) networking model, those layers are known as Layer 1 and Layer 2, respectively.

Based on the addressing scheme used in early implementations of Ethernet, the IEEE 802 standards use Media Access Control (MAC) addresses, which are unique identifiers typically assigned to endpoint access hardware by device manufacturers. The most significant part of a MAC address identifies the manufacturer, which assigns the remainder of the address, potentially providing a unique address. This makes it possible for frames to be delivered within a network that interconnects sender and receiver through some combination of Ethernet switches.

[Routers](https://www.cisco.com/c/en/us/solutions/small-business/resource-center/networking/what-is-a-router.html) are used to pass packets between networks and use IP addresses rather than MAC addresses to tag packets' origination and destination points. Using the U.S. Postal Service as an analogy, IP addresses are like ZIP codes, while MAC addresses are like street addresses or post office boxes.

### What are Ethernet frames?

In an Ethernet network, data is broken into packets, with each packet transmitted using the CSMA/CD algorithm until it arrives at its destination without colliding with any other packet. The first open slot after a transmission is reserved for an acknowledge packet. A device or node is either transmitting or receiving at any instant.

When sending data to another device on an Ethernet network, the MAC sublayer (**data link sublayer**):

- Encapsulates higher-level frames into frames appropriate for the transmission medium
- Adds a frame check sequence to identify transmission errors
- Forwards the data to the physical layer as soon as the CSMA/CD protocol permits, waiting as necessary to avoid collisions.
- Is responsible for compensating for collisions by starting retransmission when a collision ([jam signa](https://www.its.bldrdoc.gov/fs-1037/dir-020/_2902.htm)l) is detected.

When receiving data from the physical layer, the frame check sequence in the MAC block is used to ensure data integrity. It strips off the sender's Ethernet-packet preamble and padding before passing the data to the higher layers.

The Ethernet switch creates the frame by encapsulating the Ethernet packet with a preamble, which is used to synchronize the sender and receiver, followed by a 1-octet start-frame delimiter byte.

The Ethernet packet includes the data encapsulated by a header and a frame check value. The MAC header provides the source and destination MAC addresses as well as a 2-octet EtherType code indicating IPv4 or IPv6, MACsec encryption, etc. The frame ends with a frame check sequence (FCS), which is a 32-bit cyclic redundancy check used to detect any in-transit corruption of data.

### What is a CSMA/CD protocol?

When a frame is ready, the transmitting station checks to see whether the channel is idle or busy. If the channel is busy, the station waits until the channel becomes idle. If the channel is idle, the station starts transmitting and continually monitors the channel to detect collision.



## access network

| 名字                        | 示意图                                                       | 特征                           | 共用 | 传输材料                         | 其他                       |
| :-------------------------- | ------------------------------------------------------------ | ------------------------------ | ---- | -------------------------------- | -------------------------- |
| DSL digital subscriber line | ![截屏2021-11-25 下午2.56.52](https://tva1.sinaimg.cn/large/008i3skNgy1gwrejuhwyfj30nu09iaaw.jpg) | 短距离                         | 电话 | 双绞铜线(便宜)                   |                            |
| HFC hybrid fiber coax       | ![截屏2021-11-25 下午2.58.27](https://tva1.sinaimg.cn/large/008i3skNgy1gwrelepf5mj30t20d0q3z.jpg) | 每个用户都会收到 packet 的copy | 电视 | 同轴电缆(高速), 光纤             |                            |
| FTTH fiber to the home      | ![截屏2021-11-25 下午3.00.59](https://tva1.sinaimg.cn/large/008i3skNgy1gwreo25e92j30o40c0dgt.jpg) |                                |      | 光纤(高速, 不受电磁影响, 成本高) | PON(similar to cable), AON |
| LAN                         | ![截屏2021-11-25 下午3.04.55](https://tva1.sinaimg.cn/large/008i3skNgy1gwres7bkyuj30oc0d8aat.jpg) |                                |      | 双绞铜线                         |                            |

## 应用层协议

| 协议名 | 传输层协议 | 报文                                                         | 特点                                                         | 端口                      | 其他    |
| ------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- | ------- |
| HTTP   | TCP        | **request 报文**<br />GET /dir/page.html HTTP/1.1<br />HOST: www.xxx.com<br />Connection: close<br />User-agent: Mozilla/5.0<br /><br />**response 报文**<br />HTTP/1.1 200 OK<br />Connection: close<br />Date: Tue, 09 Aug 2011 15:44:04 GMT<br />Server: Apache/2.2.3 (CentOS)<br />Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br />Content-Length: 6811<br />Content-Type: text/html<br /><br />(data data data) | 无状态协议(keep-alive 简单说就是保持当前的TCP连接，避免了重新建立连接)<br />条件 get(The semantics of the GET method change to a "conditional GET" if the request message includes an **If-Modified-Since**, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). )<br />pipelining<br />https | 80                        | cookies |
| FTP    | TCP        | 略                                                           | 有状态协议:control connection (持续)和 data connection(不持续, server 发起连接)<br /> | control: 21<br />data: 20 |         |
| SMTP   | TCP        |                                                              | 强制 ASCII 要转码, 持续                                      | 25                        |         |
| DNS    | UDP        | RR: (Name, Value, Type, TTL)![截屏2021-12-06 下午7.32.16](https://tva1.sinaimg.cn/large/008i3skNgy1gx4cbpi3qoj30uo0l076o.jpg) | 分层, 分布式<br />![截屏2021-12-06 下午7.31.37](https://tva1.sinaimg.cn/large/008i3skNgy1gx4cb4kz64j310o0d6dhh.jpg) | 53                        |         |
| p2p    | TCP        |                                                              | tit for tat                                                  |                           |         |

### SMTP mail access protocol

| 协议名 | 特点                                                       |      |      |      |
| ------ | ---------------------------------------------------------- | ---- | ---- | ---- |
| POP3   | server 只有标签, 不能移动更改文件夹, 不保存用户状态信息    |      |      |      |
| IMAP   | 可以操作文件夹, 可以只获得邮件的部分内容, 保存用户状态信息 |      |      |      |
| HTTP   |                                                            |      |      |      |

## TCP UDP

| 属性                                                         | TCP                                                          | UDP                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| (de)multiplexing                                             | dest-IP, dest-port, source-IP and source-port                | dest-IP and dest-port                                        |
| connection                                                   | yes                                                          | no                                                           |
| header                                                       | 20bytes                                                      | 8bytes                                                       |
| congestion control(拥塞控制)[https://zhuanlan.zhihu.com/p/37379780] | yes                                                          | no                                                           |
| flow control(流量控制)[https://www.zhihu.com/question/32255109] | yes                                                          | no                                                           |
| segment header                                               | ![截屏2021-12-07 下午1.30.42](https://tva1.sinaimg.cn/large/008i3skNgy1gx57ht945tj30ls0mcmyh.jpg) | ![截屏2021-12-07 下午1.30.09](https://tva1.sinaimg.cn/large/008i3skNgy1gx57h9iltmj30cu0aiaad.jpg) |
| 多播广播                                                     | no(面向连接)                                                 | yes                                                          |

## TCP 三次握手四次挥手

![img](https://i0.hdslb.com/bfs/article/fb34229da30e88e37267cb7f69d19a6e8ef8e544.png@1058w_654h_progressive.webp)

- three-way-handshake
  1. c: SYN(synchronize), random initial **SYN = 1, SYNnum = x**, c->SYN_SEND
  2. s: SYNACK, allocate TCP variables and buffer, initial **SYN = 1, SYNnum = y, ACK = 1, ACKnum = x+1**, s->SYN_RCVD
  3. c: SYN = 0, allocate variables and buffer, carry payload, **SYN = 0, ACK = 1, ACKnum = y+1**, c->ESTABLISHED, s->ESTABLISHED
- 四次挥手, c 或 s 都可发起, 这里以 c 发起举例
  1. c: **FIN = 1, SYN = 0, SYNnum = x**, c->FIN_WAIT_1
  2. s: **ACK = 1, ACKnum = x+1**, c->FIN_WAIT_2, s->CLOSE_WAIT
  3. s: **FIN = 1, SYN=0, SYNnum = y**, c->TIME_WAIT, s->LAST_ACK
  4. c: **ACK = 1, ACKnum = y+1**, wait 2MSL(maximum segment lifetime), release resourses
- SYN flood 不断发送不存在的 ip 地址给 s 建立半连接 tcp 连接(即停在握手第二步结束), 消耗 s 资源
- SYN cookie: server 的 initial SYNnum 是 SYN segment 的 sourse dest ip port 做的 hash function(即 cookie)
  当 client 发回 SYNACK 时, 用 hash function 再次计算, 如果得到的值和 ack 一样, 那么说明之前已经有过半连接
- 为什么三次握手
  - 第一次握手: s 验证 c 发送能力, s 接收能力
  - 第二次握手: c 验证 s 发送接收能力, c 发送接收能力
  - 第三次握手: s 验证 s 发送能力, c 接收能力
- 为什么四次挥手
  - 各自发送终止信号, 确认终止信号

### go-back-n selective repeat



## http 状态码

200 OK 成功

301 moved permanently 永久转移

400 bad request 不能被服务器理解

404 not found

505 http version not supported

## http 请求类型

OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。

HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。

GET：向特定的资源发出请求。

POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。???

PUT：向指定资源位置上传其最新内容。

DELETE：请求服务器删除 Request-URI 所标识的资源。

TRACE：回显服务器收到的请求，主要用于测试或诊断。

CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。

## 报文等概念

报文 message 应用层

报文段 segment 传输层TCP

数据报 datagram 传输层 UDP

分组(包) packet 网络层

帧 frame 链路层

## abcde 类 ip

A类地址第1字节为网络地址，其它3个字节为主机地址。另外第1个字节的最高位固定为0。 

​	A类地址范围：1.0.0.0到127.255.255.255。 

​	A类地址中的私有地址和保留地址： 

​		10.0.0.0到10.255.255.255是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。 

　　127.0.0.0到127.255.255.255是保留地址，用做循环测试用的。 

　　0.0.0.0到0.255.255.255也是保留地址，用做表示所有的IP地址。 

​	A类地址默认子网掩码为255.0.0.0

B类地址第1字节和第2字节为网络地址，其它2个字节为主机地址。另外第1个字节的前两位固定为10。 

　B类地址范围：128.0.0.1到191.255.255.255。 

　B类地址的私有地址和保留地址 

　	172.16.0.0到172.31.255.255是私有地址 

　　169.254.0.0到169.254.255.255是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，这时你将会从169.254.0.0到169.254.255.255中临时获得一个IP地址。 

　B类地址默认子网掩码为255.255.0.0

C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。 

　　C类地址范围：192.0.0.1到223.255.255.255。 

　　C类地址中的私有地址：192.168.0.0到192.168.255.255是私有地址。 

　　C类地址默认子网掩码为255.255.255.0

D类地址不分网络地址和主机地址，它的第1个字节的前四位固定为1110。 

　　D类地址范围：224.0.0.0到239.255.255.255 

　　D类地址用于多点播送。 

　　D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。 

　　D类地址又分为三种类型：即专用地址、公用地址和私用地址；其中专用地址（224.0.0.0-224.0.0.255）用于网络协议组的广播，公用地址（224.0.1.0-238.255.255.255）用于其它组播，私用地址（239.0.0.0-239.255.255.255）用于测试。 

　　在IPv6协议中，第一个字节必须是0xFF。

E类地址也不分网络地址和主机地址，它的第1个字节的前五位固定为11110。 

　　E类地址范围：240.0.0.1到255.255.255.254 

　　E类IP地址以“llll0”开始，为将来使用保留。 

　　全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。 

　　E类IP地址的第一段数字范围为240～254，E类地址保留，仅作为搜索、Internet的实验和开发之用。













