---
categories:
- 私密
date: 2021-01-15 09:41:54
password: wzqdiary
tags:
- treenode
- pnode
- cstring
- info
- node
title: 20210114凯卓公司
---

> 简介

<!--more-->

# 回放树节点过滤

nrutree: 中心录像

mittree: 前端录像

nrumitmodel CreateNruMitTreeNode

接口测试网页: 服务器 ip:3000/explorer

先 login

```json
{"username":"admin",
"password":"888888"}
```

直接重写 addnode函数, 根节点直接加, 设备节点parent=root, 摄像头节点 parent 不变

# 收藏夹

获得 token, access token

67: 不同设备收藏进同一收藏返回的 id 不同, prepoint 不同

68: 不同设备收藏进同一收藏返回的 id 不同, prepoint 相同

```cpp
if (errNone != pModel->CreateCollect(pMit->info.oid, pCollectMitObj->info.name)) //传入对象ID和name
                            {
                                AfxMessageBox("收藏失败");
                                return;
                            }

                            TreeNode* parNode = GetParentNode(pNode);
                            CollectMitObject* parMitObj = dynamic_cast<CollectMitObject*>(parNode);
                            if(pMit->info.kind == ENCKIND)
                            {
                                //AfxMessageBox(pMitObj->info.oid);
                                CString s;
                                s.Format("%d",parMitObj->info.prepoint);
                                AfxMessageBox(s);
                                pModel->DeleteCollect(pMit->info.oid,parMitObj->info.prepoint);
                                RemoveTreeNode(pMit);
                            }

                            parMitObj->info.channel.erase(std::find(parMitObj->info.channel.begin(),parMitObj->info.channel.end(),pMit->info.oid));

                            if (GetChildCount(parNode) == 0)
                            {
                                RemoveTreeNode(parNode);
                            }        
```

```cpp
void CPreviewCollectTree::OnEvtDeleteCollect(IEventData* pData)
{
    if(pData)
    {
        DeleteCollectData* pEvtData = dynamic_cast<DeleteCollectData*>(pData);
        if (pEvtData)
        {
            CollectMitObject* pNode = dynamic_cast<CollectMitObject*>(FindMitObjectByName(pEvtData->name));

            if(pNode)
            {
                RemoveTreeNode(pNode);
            }
        }
    }
    Refreshlist();
}

void CPreviewCollectTree::OnCollectDelete()
{
    IChannelModel* pChannelModel = GetInlPtr<IChannelModel*>(_T("ChannelModel"));

    if(pChannelModel==NULL)
    {
        return;
    }
    TreeNode* pNode = GetSelNode();

    if(pNode)
    {
        MitObject* pMitObj = dynamic_cast<MitObject*>(pNode);
        if(pMitObj)
        {
            TreeNode* parNode = GetParentNode(pNode);
            CollectMitObject* parMitObj = dynamic_cast<CollectMitObject*>(parNode);
            if(parMitObj)
            {
                if(pMitObj->info.kind == ENCKIND)
                {
                    //AfxMessageBox(pMitObj->info.oid);
                    CString s;
                    s.Format("%d",parMitObj->info.prepoint);
                    AfxMessageBox(s);
                    pChannelModel->DeleteCollect(pMitObj->info.oid,parMitObj->info.prepoint);
                    RemoveTreeNode(pMitObj);
                }

                parMitObj->info.channel.erase(std::find(parMitObj->info.channel.begin(),parMitObj->info.channel.end(),pMitObj->info.oid));

                if (GetChildCount(parNode) == 0)
                {
                    RemoveTreeNode(parNode);
                }
            }
        }
        else
        {
            CollectMitObject* pCollectMitObj=dynamic_cast<CollectMitObject*>(pNode);
            if (pCollectMitObj)
            {
                std::vector<CString>::iterator its;
                for(its=pCollectMitObj->info.channel.begin();its!=pCollectMitObj->info.channel.end();its++){
                    pChannelModel->DeleteCollect(*its,pCollectMitObj->info.prepoint);
                }
                std::vector<TreeNode*> Children;
                GetChildNode(pNode,Children);
                std::vector<TreeNode*>::iterator iter;
                for (iter = Children.begin();iter != Children.end();iter++)
                {
                    RemoveTreeNode(*iter);
                }

                RemoveTreeNode(pNode);
            }

        }
    }
Refreshlist();
}
```

```cpp
void CReplayMITTree::AddTreeNode(TreeNode* parent,TreeNode* before,TreeNode* node)
{
    bool flag;
    MitObject* object_node = dynamic_cast<MitObject*>(node);
    CString fulname = object_node->info.fullname;
    fulname.MakeUpper();

    flag = (object_node->info.oid.Find("-") != -1) || (object_node->info.oid == "root")|| (fulname.Find("NVR")!=-1)||(fulname.Find("CVR")!=-1);
    if (flag)
    {
        if (!FilterTreeNode(node))
        {
            return;
        }
        HTREEITEM itemP=NULL;//=
        HTREEITEM itemB=NULL;//FindHandle(before);
        if (NULL==parent)
        {
            itemP=TVI_ROOT;
        }
        else
        {
            itemP=FindHandle(parent);

            if (NULL==itemP)
            {
                //没有父节点的树节点不添加
                return;
            }
        }

        if (NULL==before)
        {
            itemB=TVI_FIRST;
        }
        else
        {
            itemB=FindHandle(before);
            if (NULL==itemB)
            {
                //找不到插入节点，追加到末尾
                itemB=TVI_LAST;
            }
        }
        HTREEITEM item=InsertItem(_T(""),itemP,itemB);
        OnSetNodeData(item,node);
        Invalidate();
    }
}
```

```cpp
CTreeCtrlEx* ptree = &refCtrl;
    CReplayMITTree* replayTree = dynamic_cast<CReplayMITTree*>(ptree);
    if(replayTree)
    {
        replayTree->RemoveUselessNode(ptree, ptree->FindHandle(pMObj));
    }
```

```cpp
void CReplayMITTree::RemoveUselessNode(CTreeCtrlEx* tree, HTREEITEM item){
    HTREEITEM curItem = tree->GetChildItem(item);
    HTREEITEM nextItem;
    while(curItem){
        TreeNode* pNode=NULL;
        ValidateTreeNode(pNode, curItem);
        if (pNode&&GetChildCount(pNode)==0)
        {
            MitObject* object_node = dynamic_cast<MitObject*>(pNode);
            if(object_node){
                CString name = object_node->info.fullname;
                name.MakeUpper();
                if(object_node->info.fullname.Find("CVR")==-1&&object_node->info.fullname.Find("NVR")==-1)
                {
                    RemoveTreeNode(pNode);
                    return;
                }
            }
        }
        nextItem = curItem;
        RemoveUselessNode(tree, nextItem);
        curItem = tree->GetNextSiblingItem(curItem);
    }
    TreeNode* pNode=NULL;
    ValidateTreeNode(pNode, nextItem);
    if (pNode&&GetChildCount(pNode)==0)
    {
        MitObject* object_node = dynamic_cast<MitObject*>(pNode);
        if(object_node){
            CString name = object_node->info.fullname;
            name.MakeUpper();
            if(object_node->info.fullname.Find("CVR")==-1&&object_node->info.fullname.Find("NVR")==-1)
                RemoveTreeNode(pNode);
        }

    }
}
```

modify systemconfig2 replay1preview2

previewdevicetree

previewcollecttree

cdevicetree

careatree

```cpp
//都是继承自 treenode
struct CollectMitObjInfo
{
    CString id;                // id
    std::vector<CString> channel;        // 通道 (oids)
    CString name;            // 名称(区域，设备，通道对象名称)
    long prepoint;                // 
    long kind;              //定义为收藏夹种类
}

struct MitObjInfo
{
    CString oid;            // 对象ID
    CString name;            // 名称(区域，设备，通道对象名称)
    CString fullname;        // 全称
    long kind;                // 种类
    long type;                // 种类
}

CreateCollectData{
    public:
    CString id;
    CString channel;
    CString name;
    ULONG prepoint;            
}

DeleteCollectData{
      CString id;
    CString name;
  //id 和 name 都是收藏夹
}

struct CollectInfo
{
    CString id;                                                // id
    CString channel;                                        // 通道
    CString name;                                            // 名称
    ULONG prepoint;                                            // 预置点
};
```

```cpp
LONG CChannelModel::CreateCollect(const CString& channel, const CString& name)
{
    IConnectModel* pModel=GetInlPtr<IConnectModel*>(_T("ConnectModel"));
    if (pModel)
    {
        SDPHANDLE handle=pModel->GetHandle();
        if (handle)
        {
            Json::FastWriter writer;

            Json::Value param,value,resp;
            value["id"] = channel.GetString();
            value["name"] =name.GetString();
            LONG temp = instanceRMIManager()->rest_put(handle,"Channels/createCollect",param,value,resp);
            if(temp ==errNone)
                Notify(EVT_CREATE_COLLECT,0);
            return     temp;    
        }
    }

    return errError;
}

void CChannelModel::CallbackCreateCollectProc(void* pthis, void* hLink, STR tid, const void* pEvt)
{
    CChannelModel* 
    =(CChannelModel*)(pthis);
    if(pEvt && pThis)
    {
        IConnectModel* pModel=GetInlPtr<IConnectModel*>(_T("ConnectModel"));
        if (pModel==NULL)
        {
            return;
        }
        Json::Value jsEvt;
        if (SDPJson::parse((char*)pEvt, jsEvt))
        {
            CString user = jsEvt["user"].asCString();
            CString curUser = pModel->GetUserName();
            if (user!=curUser)
            {
                return;
            }

            CreateCollectData data;
            data.id=jsEvt["id"].asCString();
            data.channel=jsEvt["oid"].asCString();
            data.name=jsEvt["name"].asCString();
            data.prepoint=(ULONG)jsEvt["prepoint"].asInt();
            pThis->Notify(EVT_CREATE_COLLECT,&data);
        }
    }
}
```

callback 和 on 是分开的, 一个响应一个回调

```cpp
void CMitModel::OnEvtDestroyMitObj(CString oid)
notify EVT_MITOBJ_REMOVE
void CMitTreeCtrl::OnMitObjRemove(IEventData* pData)
MitObjRemoveEvtData

void CTreeCtrlEx::ClearAllNodes()
{
​    HTREEITEM root=GetRootItem();
​    ClearItemData(root);
​    DeleteAllItems();
}

void CTreeCtrlEx::ClearItemData(HTREEITEM item)
{
    std::vector<HTREEITEM> buf;
    GetChildrenItem(item,buf);

    std::vector<HTREEITEM>::iterator its;

    for (its=buf.begin();its!=buf.end();its++)
    {
        ClearItemData(*its);
    }
    if (item==TVI_ROOT)
    {
        return;
    }
    if (item)
    {
        TreeNode* pTemp=(TreeNode*)GetItemData(item);
        if (pTemp)
        {
            OnRemoveNodeData(pTemp);
        }
    }
}

void CMitTreeCtrl::OnRemoveNodeData(TreeNode* pNode)  CTreeCtrlEx::OnRemoveNodeData(pNode);

void CTreeCtrlEx::RemoveTreeNode(TreeNode* node)
{
    HTREEITEM item=FindHandle(node);
    if (item)
    {
        ClearItemData(item);
        DeleteItem(item);
    }
}
```

# ctreectrlex

void CTreeCtrlEx::AddTreeNode(TreeNode* parent,TreeNode* before,TreeNode* node)

​    HTREEITEM item=InsertItem(_T(""),itemP,itemB);?

```cpp
BEGIN_MESSAGE_MAP(CTreeCtrlEx, CTreeCtrl)
    ON_WM_DESTROY()
    ON_NOTIFY_REFLECT(NM_DBLCLK, &CTreeCtrlEx::OnNMDblclk)
    ON_NOTIFY_REFLECT(TVN_BEGINLABELEDIT, &CTreeCtrlEx::OnTvnBeginlabeledit)
    ON_NOTIFY_REFLECT(TVN_ENDLABELEDIT, &CTreeCtrlEx::OnTvnEndlabeledit)
    ON_NOTIFY_REFLECT(NM_RCLICK, &CTreeCtrlEx::OnNMRClick)
    ON_NOTIFY_REFLECT(NM_CLICK, &CTreeCtrlEx::OnNMClick)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, &CTreeCtrlEx::OnTvnItemexpanding)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, &CTreeCtrlEx::OnTvnItemexpanded)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnToolTipText)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnToolTipText)
    ON_NOTIFY_REFLECT(TVN_BEGINDRAG, OnBegindrag)
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_TIMER()
END_MESSAGE_MAP()

BEGIN_CUEVT_MAP(CTreeCtrlEx)
ON_CUEVT_HANDLE(EVT_TREENODE_ADD,OnTreeNodeAdd)
ON_CUEVT_HANDLE(EVT_TREENODE_REMOVE,OnTreeNodeRemove)
ON_CUEVT_HANDLE(EVT_TREENODE_MODIFY,OnTreeNodeModify)
ON_CUEVT_HANDLE(EVT_TREENODE_CLEAR,OnTreeNodeClear)
END_CUEVT_MAP(CTreeCtrlEx)
```

```cpp
void CTreeCtrlEx::ClearAllNodes()
{
    HTREEITEM root=GetRootItem();
    ClearItemData(root);
    DeleteAllItems();
}

void CTreeCtrlEx::RemoveTreeNode(TreeNode* node)
{
    HTREEITEM item=FindHandle(node);
    if (item)
    {
        ClearItemData(item);
        DeleteItem(item);
    }
}

void CTreeCtrlEx::ModifyTreeNode(TreeNode* node)
{
    if (!FilterTreeNode(node))
    {
        return;
    }
    HTREEITEM item=FindHandle(node);
    if (item)
    {
        TreeNode* preNode=(TreeNode*)GetItemData(item);
        if (preNode)
        {
            delete preNode;
            preNode=NULL;
        }
        OnSetNodeData(item,node);
    }
}

void CTreeCtrlEx::AddTreeNode(TreeNode* parent,TreeNode* before,TreeNode* node)
{
    if (!FilterTreeNode(node))
    {
        return;
    }
    HTREEITEM itemP=NULL;//=
    HTREEITEM itemB=NULL;//FindHandle(before);
    if (NULL==parent)
    {
        itemP=TVI_ROOT;
    }
    else
    {
        itemP=FindHandle(parent);
        if (NULL==itemP)
        {
            return;
        }
    }
    if (NULL==before)
    {
        itemB=TVI_FIRST;
    }
    else
    {
        itemB=FindHandle(before);
        if (NULL==itemB)
        {
            itemB=TVI_LAST;
        }
    }
    HTREEITEM item=InsertItem(_T(""),itemP,itemB);
    if (m_bTriMode)
    {
        SetItemState(item, INDEXTOSTATEIMAGEMASK(1), TVIS_STATEIMAGEMASK);
    }
    OnSetNodeData(item,node);
    Invalidate();
}
```

区域节点双击, 遇到不适当的参数 √

画面分屏定位不准24, 25  删掉

js script abort exception
