---
categories:
- 私密
date: 2020-10-22 16:51:43
password: wzqdiary
tags:
- pmitobj
- oid
- info
- kind
- pmodel
title: 设备列表编辑
---

>简介

<!--more-->

# 设备列表编辑

## 需求

1）支持在平台客户端软件界面显示监控点列表；
2）监控点列表应可编辑、分组、排序、数量统计（在线数/总数），方便查找前端监控点，避免在前端监控点较多时监控点列表排序混乱无规律的情况；
3）支持对选中的单个监控点或监控点分组进行鼠标双击和拖动显示实时视频。

> 设备添加
>
> 用户名:admin
>
> 密码:12345
>
> 大华半球的用户名密码：
>
> admin
>
> admin

## 设计

### 右键添加分组

右键响应函数->添加对话框弹出(systemconfig)

### 拖拽节点排序

发消息到配置: 修改区域

### 拖拽区域节点预览



## 交接

preview/previewdevicetree

区域管理



# knowledge

## [ON_COMMAND,ON_MESSAGE和ON_NOTIFY的区别](https://blog.csdn.net/gongxifacai_believe/article/details/51052071)

对这几个消息的理解要先了解一下Window消息的背景。
   在Windows3.1里，控件会将mouse, keybord等等的消息通知它的父窗口，使用的消息就只有WM_COMMAND, 事件种类和控件ID被包含在wParam中，控件的句柄包含在lParam中。由于wParam和 lParam已经满了，当控件要向父窗口发送其它特殊消息同时附带很多信息的时候就没有地方可以存放它们了。所以Windows3.1中定义了许多其它的消息种类，比如WM_VSCROLL, WM_CTLCOLOR等等，每种消息wParam,lParam中附带的信息是不同的。
   当到了Win32后，控件的种类越来越多，当然不可以为每一个控件都定义一套消息，这样也不利于系统的扩充。所以在Win32中定义了唯一一个强大的消息 WM_NOTIFY。当然WM_NOTIFY也遵守原来的消息规则，即只带参数wParam和lParam。唯一不同处在于，此时的lParam中传送的是一个NMHDR指针。不同的控件可以按照规则对NMHDR进行扩充，因此WM_NOTIFY消息传送的信息量可以相当的大，这个可以看看MSDN中的相关说明，TreeControl中就有很多这种消息。

   现在就可以知道为什么有ON_MESSAGE ，ON_COMMAND, , ON_NOTIFY了。
   ON_MESSAGE是处理所有的Windows的消息的，因为所有的消息都以相同的格式传送，也就是ID, WPARAM, LPARAM.
   ON_COMMAND是专门处理WM_COMMAND消息的，这样我们就不用自己解开WM_COMMAND中wParam和lParam中传送的控件ID，事件种类…（所有的都在MFC内部解决了：），当然方便了。
   ON_NOTIFY更是不用说了，看看他的处理函数，是不是把NMHDR解出来了。

   这样一样就一目了然了，ON_COMMAND和ON_NOTIFY都可以用ON_MESSAGE来处理，只不过自己要多做很多事情。ON_COMMAND和ON_NOTIFY最好就不要互换了！

## ID

**IDC->ID  of  Control** 
**IDI->ID  of  Icon** 
**IDB->ID  of  Bitmap** 
**IDD->ID  of  Dialog** 
**IDS->ID  of  String**

控件资源的标识，例如：IDC_EDIT、IDC_BUTTON、IDI_MENU、IDD_POP等。这些标识都是唯一的数值来标识，你也可以通过这些标识可以得到控件的句柄等。

VC为了标识不同的资源而使用的符号，其实他们都是数字，在resource.h中可以找到它们，是有一定规律的，不是随机的。一般我们不用去改动它们，只要在资源里面编辑就行，都是define定义的数据。***ID是资源的唯一标识，本质上是一个无符号整数，一般ID代表的整数值由系统定义，我们无需干涉。***

## ctreectrl

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gk0dyrok2sj306619yt9n.jpg" alt="截屏2020-10-24 下午2.02.21" style="zoom:25%;" />



## 实现

### 右键添加分组

添加菜单在 IDR_PREVIEW_MITMENU AREA 里

代码在 previewDeviceTree.cpp

**AfxMessageBox("?");**

右键菜单在已有的菜单上加了一项, 然后设置事件(手动, oncommand, 声明, 实现)

新 addareadlg 类, 输入名字和描述

然后通过previewDeviceDlg/HMENU CPreviewDeviceTree::GetItemMenu(HTREEITEM item,TreeNode* pNode) 获得右键节点的 oid

把 oid, 名字, 描述放在 IDeviceManageModel* pModel=GetInlPtr<IDeviceManageModel*>(_T("DeviceManageModel")); 里新建分组

后面的都是草fei稿hua

```cpp
VideoGroupObject* pGObj=dynamic_cast<VideoGroupObject*>(pNode);
```

```cpp
previewdevicetree.cpp
void CPreviewDeviceTree::OnChannelCreateCollect()
```



菜单 id: ID_AREA_ADD

```cpp
BEGIN_MESSAGE_MAP(CPreviewDeviceTree, CMitTreeCtrl)
	ON_COMMAND(ID_AREA_ADD,OnAreaAdd)
END_MESSAGE_MAP()

void CPreviewDeviceTree::OnAreaAdd()
{
  IDeviceManageModel* pModel=GetInlPtr<IDeviceManageModel*>(_T("DeviceManageModel"));
  if (pModel)
  {
    CAddAreaDlg m_addareadlg(this);
    m_addareadlg.DoModal();
    CString name,parent,desc;
    name = m_addareadlg.m_name;
    desc = m_addareadlg.m_desc;
    parent = m_nodeparent;
    if (errNone!=pModel->AddArea(parent, name, desc))
    {
      MessageBox("创建失败");
    }	
  }
}
```



![截屏2020-10-30 下午7.59.20](https://tva1.sinaimg.cn/large/0081Kckwly1gk7m0253e1j30p80cewfq.jpg)

```cpp
HMENU CPreviewDeviceTree::GetItemMenu(HTREEITEM item,TreeNode* pNode)
{
	CString str1,str2,str3,str4,str5,str6;

	BEGIN_MODULE_RESOURCE
	
	str1.LoadString(IDS_STRING62);
	str2.LoadString(IDS_STRING63);
	str3.LoadString(IDS_STRING64);
	str4.LoadString(IDS_STRING65);
	str5.LoadString(IDS_STRING66);
	str6.LoadString(IDS_STRING67);

	END_MODULE_RESOURCE
	if (pNode)
	{
		MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
		m_nodeparent = pMitObj->info.oid;
		CString number;
		number.Format("%d",pMitObj->info.kind);
		AfxMessageBox(number);
		if (pMitObj)
		{

			if (GETOBJKIND(pMitObj->info.kind)==EMitObjKind_ne)
			{
				CMenu* pMenu=m_preMenu.GetSubMenu(0);
				if(pMitObj->status.link == 0)			//设备在线
				{
					pMenu->EnableMenuItem(ID_DEVICE_TALKBACK,MF_BYCOMMAND|MF_ENABLED);

					IVoiceControl* pControl=GetInlPtr<IVoiceControl*>(_T("VoiceControl"));
					if (pControl)
					{
						CString oid;
						if (pControl->GetOpenVoiceTalk(oid))
						{
							//当前设备正在语音对讲
							if (pMitObj->info.oid==oid)
							{

								pMenu->ModifyMenu(ID_DEVICE_TALKBACK,MF_BYCOMMAND,ID_DEVICE_TALKBACK,str2);

							}
							else
							{
								pMenu->ModifyMenu(ID_DEVICE_TALKBACK,MF_BYCOMMAND,ID_DEVICE_TALKBACK,str1);
							}
						}
						//没有设备语音对讲
						else
						{
							pMenu->ModifyMenu(ID_DEVICE_TALKBACK,MF_BYCOMMAND,ID_DEVICE_TALKBACK,str1);
						}
					}
					else
					{
						pMenu->EnableMenuItem(ID_DEVICE_TALKBACK,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);

					}
				}
				else									//设备离线
				{
					pMenu->EnableMenuItem(ID_DEVICE_PREVIEW,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_DEVICE_CLOSE,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_DEVICE_TALKBACK,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);			
				}
				
				return pMenu->GetSafeHmenu();
			}
			else if (pMitObj->info.kind==ENCKIND || pMitObj->info.kind ==TURNTABLEENCKIND)
			{
				CMenu* pMenu=NULL;	
				pMenu=m_preMenu.GetSubMenu(1);
				if(pMitObj->status.link == 0)			//设备通道在线
				{
					if (pMitObj->status.stream!=0)
					{
						pMenu->CheckMenuRadioItem(ID_CHANNEL_MAINSTREAM,ID_CHANNEL_SUBSTREAM,ID_CHANNEL_SUBSTREAM,MF_BYCOMMAND);	
					}
					else
					{
						pMenu->CheckMenuRadioItem(ID_CHANNEL_MAINSTREAM,ID_CHANNEL_SUBSTREAM,ID_CHANNEL_MAINSTREAM,MF_BYCOMMAND);	
					}
				}
				else									//设备通道离线					
				{
					pMenu->EnableMenuItem(ID_CHANNEL_MAINSTREAM,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_CHANNEL_SUBSTREAM,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_CHANNEL_CLOSE,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);						
					pMenu->EnableMenuItem(ID_CHANNEL_CREATE_COLLECT,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_CHANNEL_ALARMFLAG,MF_BYCOMMAND|MF_ENABLED);
				}
				
				return pMenu->GetSafeHmenu();
			}
			else if (pMitObj->info.kind==AREAKIND)
			{
				CMenu* pMenu=m_preMenu.GetSubMenu(2);
				return pMenu->GetSafeHmenu();
			}
			else if (pMitObj->info.kind==CMSKIND)
			{
				CMenu* pMenu=m_preMenu.GetSubMenu(3);
				return pMenu->GetSafeHmenu();
			}
		}
		
	}

	return NULL;
}
```



Source\SystemConfig\AreaManage\AreaAddDlg.cpp

Source\SystemConfig\AreaManage\AreaManageDlg.cpp

```cpp
void CAreaManageDlg::AddArea()
{
	CAreaAddDlg dlg(this);
	if(IDOK == dlg.ShowModal())
	{
		// 接口调用
		IDeviceManageModel* pModel=GetInlPtr<IDeviceManageModel*>(_T("DeviceManageModel"));
		if (pModel)
		{
			CString name,parent,descirbe;

			dlg.GetParam(name, parent, descirbe);
			if (errNone!=pModel->AddArea(parent, name, descirbe))
			{
				MessageBox("创建失败");
			}	
		}
	}
}

```

Source\SystemConfig\AreaManage\AreaListCtrl.cpp

```cpp
void CAreaListCtrl::OnMenuAreaAdd()
{
   CAreaManageDlg* pUI = dynamic_cast<CAreaManageDlg*>(GetParent());
   if(pUI)
   {
      pUI->AddArea();
   }
}

private:
	CMenu  m_areaMenu;     // 区域菜单

CAreaListCtrl::CAreaListCtrl()
{
	BEGIN_MODULE_RESOURCE
	m_areaMenu.LoadMenu(IDR_AREAMAN_MENU);
	END_MODULE_RESOURCE

	IModel* pModel=GetInlPtr<IModel*>(_T("DeviceManageModel"));
	if (pModel)
	{
		pModel->RegEvtArea(this);
	}
}
```



Source\Preview\PreviewDeviceTree.cpp

```cpp
HMENU CPreviewDeviceTree::GetItemMenu(HTREEITEM item,TreeNode* pNode)
{
	CString str1,str2,str3,str4,str5,str6;
	BEGIN_MODULE_RESOURCE
	
	str1.LoadString(IDS_STRING62);
	str2.LoadString(IDS_STRING63);
	str3.LoadString(IDS_STRING64);
	str4.LoadString(IDS_STRING65);
	str5.LoadString(IDS_STRING66);
	str6.LoadString(IDS_STRING67);

	END_MODULE_RESOURCE
	if (pNode)
	{
		MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
		if (pMitObj)
		{
			if (GETOBJKIND(pMitObj->info.kind)==EMitObjKind_ne)
        /*
        未定义         EMitObjKind_undef = 0,
        管理服务器对象   EMitObjKind_nm = 1,
        设备对象        EMitObjKind_ne = 2,
        端口对象        EMitObjKind_port = 3,
        通道对象        EMitObjKind_chn = 4,
        矩阵对象        EMitObjKind_matrix = 5,
        组对象        EMitObjKind_group = 6,
        区域        EMitObjKind_area = 7,
        转台        EMitObjKind_turntable = 8,
        收藏夹        EMitObjKind_collect = 9,
        */
			{
				CMenu* pMenu=m_preMenu.GetSubMenu(0);
				if(pMitObj->status.link == 0)			//设备在线
				{
					pMenu->EnableMenuItem(ID_DEVICE_TALKBACK,MF_BYCOMMAND|MF_ENABLED);
					IVoiceControl* pControl=GetInlPtr<IVoiceControl*>(_T("VoiceControl"));
					if (pControl)
					{
						CString oid;
						if (pControl->GetOpenVoiceTalk(oid))
						{
							//当前设备正在语音对讲
							if (pMitObj->info.oid==oid)
							{
                pMenu->ModifyMenu(ID_DEVICE_TALKBACK,MF_BYCOMMAND,ID_DEVICE_TALKBACK,str2);
							}
							else
							{
								pMenu->ModifyMenu(ID_DEVICE_TALKBACK,MF_BYCOMMAND,ID_DEVICE_TALKBACK,str1);
							}
						}
						//没有设备语音对讲
						else
						{
							pMenu->ModifyMenu(ID_DEVICE_TALKBACK,MF_BYCOMMAND,ID_DEVICE_TALKBACK,str1);
						}
					}
					else
					{
						pMenu->EnableMenuItem(ID_DEVICE_TALKBACK,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					}
				}
				else									//设备离线
				{
					pMenu->EnableMenuItem(ID_DEVICE_PREVIEW,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_DEVICE_CLOSE,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_DEVICE_TALKBACK,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
				}
				return pMenu->GetSafeHmenu();
			}
			else if (pMitObj->info.kind==ENCKIND || pMitObj->info.kind ==TURNTABLEENCKIND)
        /*
        const long CMSKIND=MAKEOBJKIND(EMitObjKind_nm, EMitObjKind_NM_cms);				//65537
const long ONVIF_DVRKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_onvifdvr);	//131081
const long HK_DVRKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_hkdvr);		//131083
const long DH_DVRKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_dhdvr);		//131084
const long HP_DVRKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_hpdvr);		//131097
const long VTDUKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_vtdu);			//131075
const long NRUKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_nru);				//131076
const long GWKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_gw);				//131077
const long VAUKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_vau);				//131092
const long ENCKIND=MAKEOBJKIND(EMitObjKind_chn, EMitObjKind_CHN_enc);			//262145
const long GROUPKIND=MAKEOBJKIND(EMitObjKind_group, 0);							//
const long AREAKIND=MAKEOBJKIND(EMitObjKind_area, 0);							//458752
const long DIAGNOSISKIND=MAKEOBJKIND(EMitObjKind_ne, 99);
const long TURNTABLEKIND=MAKEOBJKIND(EMitObjKind_turntable, 0);					//
const long TURNTABLEENCKIND=MAKEOBJKIND(EMitObjKind_turntable, EMitObjKind_CHN_enc);	
const long COLLECTKIND=MAKEOBJKIND(EMitObjKind_collect, 0);//
        */
			{
				CMenu* pMenu=NULL;	
				pMenu=m_preMenu.GetSubMenu(1);
				if(pMitObj->status.link == 0)			//设备通道在线
				{
					if (pMitObj->status.stream!=0)
					{
						pMenu->CheckMenuRadioItem(ID_CHANNEL_MAINSTREAM,ID_CHANNEL_SUBSTREAM,ID_CHANNEL_SUBSTREAM,MF_BYCOMMAND);	
					}
					else
					{
						pMenu->CheckMenuRadioItem(ID_CHANNEL_MAINSTREAM,ID_CHANNEL_SUBSTREAM,ID_CHANNEL_MAINSTREAM,MF_BYCOMMAND);	
					}
				}
				else									//设备通道离线					
				{
					pMenu->EnableMenuItem(ID_CHANNEL_MAINSTREAM,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_CHANNEL_SUBSTREAM,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_CHANNEL_CLOSE,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);						
					pMenu->EnableMenuItem(ID_CHANNEL_CREATE_COLLECT,MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
					pMenu->EnableMenuItem(ID_CHANNEL_ALARMFLAG,MF_BYCOMMAND|MF_ENABLED);
				}
				
				return pMenu->GetSafeHmenu();
			}
			else if (pMitObj->info.kind==AREAKIND)
			{
				CMenu* pMenu=m_preMenu.GetSubMenu(2);
				return pMenu->GetSafeHmenu();
			}
			else if (pMitObj->info.kind==CMSKIND)
			{
				CMenu* pMenu=m_preMenu.GetSubMenu(3);
				return pMenu->GetSafeHmenu();
			}
		}
	}
	return NULL;
}
```

PreviewRightDlg: PreviewDevCtrlDlg

previewLeftDlg: CPreviewDeviceDlg

previewdevicetree 应该位于视图的最上面

### 拖拽节点排序

菜单 ID_AREA_CHANGE

ID_MENU_LIST_DEVICE_MODIFY

kind = 458752  EMitObjKind_area  AREAKIND

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc67pqdvmj30aw042wfx.jpg" alt="截屏2020-11-03 下午6.33.22" style="zoom:25%;" />

458752 AREAKIND=MAKEOBJKIND(EMitObjKind_area, 0);	

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc67r2uy5j30ao06o40g.jpg" alt="截屏2020-11-03 下午6.33.15" style="zoom:25%;" />

262145 ENCKIND=MAKEOBJKIND(EMitObjKind_chn, EMitObjKind_CHN_enc);

<img src="https://tva1.sinaimg.cn/large/0081Kckwly1gkc67rmt2hj308406qmyh.jpg" alt="截屏2020-11-03 下午6.33.10" style="zoom:25%;" />

**131083** 设备节点 HK_DVRKIND=MAKEOBJKIND(EMitObjKind_ne, EMitObjKind_NE_hkdvr);



[HitTest(CPoint point, UINT uFlag)](https://blog.csdn.net/acoolgiser/article/details/81331575) 测试 point 所在的位置 TVHT_ONITEM

查一查 areaId 是个啥

按照移动到的节点分类:

- 如果是区域节点, 就直接 areaId
- 如果是子节点, 就要寻找 areaId
- areaId 就是area 节点的 oid

```cpp
void CDeviceTree::OnMenuDeviceModify()
{
	CString oid;
	TreeNode* pNode=GetSelNode();
	MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
	if (pMitObj)
	{
		oid = pMitObj->info.oid;
	}

	CDeviceModifyDlg dlg(oid, this->GetParent());
	if(IDOK == dlg.ShowModal())
	{
		// 接口调用
		IDeviceManageModel* pModel=GetInlPtr<IDeviceManageModel*>(_T("DeviceManageModel"));
		if (pModel)
		{
			EncoderInfo modparam;
			dlg.GetParam(modparam);
			pModel->ModifyDevice(modparam);
		}
	}
}

//getparam
void CDeviceModifyDlg::GetParam(EncoderInfo& modparam)
{
	modparam.id = m_param.id;
	modparam.name = m_strName;
	modparam.sn = m_param.sn;
	modparam.addr = m_param.addr;	
	modparam.port = m_param.port;
	modparam.user = m_strUser;
	modparam.password = m_strPwd;
	modparam.areaId = m_strAreaId;
	modparam.groupId = m_strGroupId;
	modparam.kind = m_param.kind;
	modparam.type = m_param.type;
	modparam.latitude.degree = m_nLatD;
	modparam.latitude.minute = m_nLatM;
	modparam.latitude.second = m_nLatS;
	modparam.longitude.degree = m_nLongD;
	modparam.longitude.minute = m_nLongM;
	modparam.longitude.second = m_nLongS;
	modparam.powerIp = m_strPowerIp;
	modparam.powerIndex = m_nPowerIndex;
}

IAreaModel* pModel = GetInlPtr<IAreaModel*>(_T("AreaModel"));
			if (pModel)
			{
				if (errNone==pModel->Find(oid, info))
				{
					return true;
				}
			}
```

```cpp
void CPreviewDeviceTree::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bDragging)
	{
		VERIFY (m_pDragImage->DragLeave (GetDesktopWindow ()));	
		m_pDragImage->EndDrag ();

		if (m_pDragImage)
		{
			delete m_pDragImage;
			m_pDragImage=NULL;
		}
		VERIFY (::ReleaseCapture ());
		m_bDragging = FALSE;

		HCURSOR cur=::LoadCursor(NULL,MAKEINTRESOURCE(IDC_ARROW));
		SetCursor(cur);

		CPoint pt (point);
		ClientToScreen (&pt);
		UINT uFlag;
		HTREEITEM targetItem = HitTest(point, &uFlag);
		if(uFlag&TVHT_ONITEM)
		{
			TreeNode* targetNode = (TreeNode*)(GetItemData(targetItem));
			MitObject* pTargetMitObj=dynamic_cast<MitObject*>(targetNode);
			if (pTargetMitObj->info.kind == AREAKIND)
			{
				if(pTargetMitObj)
				{
					TreeNode* pNode=(TreeNode*)(GetItemData(m_hDragItem));
					MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
					if (pMitObj)
					{
						//CString kind;
						//kind.Format("%d", pMitObj->info.kind);
						//AfxMessageBox(kind);
						if(pMitObj->info.kind == HK_DVRKIND)
						{
							EncoderInfo m_param;
							EncoderInfo info;
							IEncoderModel* pEncoderModel=GetInlPtr<IEncoderModel*>(_T("EncoderModel"));
							CString oid = pMitObj->info.oid;
							if (errNone == pEncoderModel->Find(oid, info))
							{
								//AfxMessageBox(info.name);
								m_param.id = info.id;
								m_param.name = info.name;
								m_param.sn = info.sn;
								m_param.addr = info.addr;
								m_param.port = info.port;
								m_param.user = info.user;
								m_param.password = info.password;
								m_param.areaId = pTargetMitObj->info.oid;
								m_param.groupId = info.groupId;
								m_param.kind = info.kind;
								m_param.type = info.type;
								m_param.latitude = info.latitude;
								m_param.longitude = info.longitude;
								m_param.powerIp = info.powerIp;
								m_param.powerIndex = info.powerIndex;
							}

							IDeviceManageModel* pDevManModel=GetInlPtr<IDeviceManageModel*>(_T("DeviceManageModel"));
							if(pDevManModel)
							{
								pDevManModel->ModifyDevice(m_param);
							}
						}
						else if(pMitObj->info.kind == AREAKIND)
						{

						}
						else
						{
							AfxMessageBox(_T("不能拖动此节点！"));
						}
					}
				}
			}
			else
			{
				AfxMessageBox(_T("不能拖到此节点！"));
			}
			return ;
		}
		else
		{
			TreeNode* pNode=(TreeNode*)(GetItemData(m_hDragItem));//选中的节点
			if (OnTreeNodeDragDrop(m_hDragItem,pNode))
			{
				IVideoPreviewModel* pModel=GetInlPtr<IVideoPreviewModel*>(_T("VideoPreviewModel"));
				if (pModel)
				{
					MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
					if (pMitObj)
					{
						CString oid;
						long kind = pMitObj->info.kind;
						//区域分组areakind

						//拖拽通道
						if (pMitObj->info.kind==ENCKIND)
						{
							oid = pMitObj->info.oid;
							pModel->SendPointToPreviewScreen(pt, oid, kind);				
						}
						//拖拽转台通道
						else if (pMitObj->info.kind==TURNTABLEENCKIND)
						{
							UINT nIndex = pModel->GetSelectItem();
							CHAR szPid[MITOIDLEN] = {0};
							TMitObjIdKVPair kv;
							char * p = (char*)(LPCTSTR)(pMitObj->info.oid); 
							char * pIdx = strstr(p,"\\tv=1");
							if(pIdx)
							{
								memcpy(szPid,p,pIdx-p);
							}
							else
							{
								mitGetPid(pMitObj->info.oid, MITOIDLEN, szPid, &kv);
							}
							oid = szPid;
							pModel->SendPointToPreviewScreen(pt, oid, kind);	
						}
						//拖拽设备
						else if (pMitObj->info.kind==ONVIF_DVRKIND||pMitObj->info.kind==HK_DVRKIND||pMitObj->info.kind==DH_DVRKIND)
						{

							std::vector<HTREEITEM> buf;
							GetChildrenItem(m_hDragItem,buf);
							std::vector<HTREEITEM>::iterator its;
							for (its=buf.begin();its!=buf.end();its++)
							{
								TreeNode* pCNode=(TreeNode*)GetItemData(*its);
								MitObject* pCMitObj=dynamic_cast<MitObject*>(pCNode);
								if (pCMitObj)
								{
									if (pCMitObj->info.kind==ENCKIND)
									{
										oid = pMitObj->info.oid;
										pModel->SendPointToPreviewScreen(pt, oid, kind);	
									}
								}
							}
						}
						else if(pMitObj->info.kind==AREAKIND)
						{
							pModel->SendPointToPreviewScreen(pt, pMitObj->info.oid, pMitObj->info.kind);
							std::vector<HTREEITEM> buf;
							GetChildrenItem(m_hDragItem,buf);
							std::vector<HTREEITEM>::iterator its;
							for (its=buf.begin();its!=buf.end();its++)
							{
								std::vector<HTREEITEM> child_buf;
								GetChildrenItem(*its,child_buf);
								std::vector<HTREEITEM>::iterator child_its;
								for (child_its=child_buf.begin();child_its!=child_buf.end();child_its++)
								{
									TreeNode* pCNode=(TreeNode*)GetItemData(*child_its);
									MitObject* pCMitObj=dynamic_cast<MitObject*>(pCNode);
									if (pCMitObj)
									{
										//AfxMessageBox(pCMitObj->info.name);
										if (pCMitObj->info.kind==ENCKIND)
										{
											oid = pCMitObj->info.oid;
											pModel->SendPointToPreviewScreen(pt, oid, pCMitObj->info.kind);
										}
									}
								}
							}
						}
					}			
				}
			}
		}
	}
	SelectDropTarget(NULL);
	Invalidate();
	CTreeCtrl::OnLButtonUp(nFlags, point);
}
```



### 拖拽区域节点预览

先 send area 通知, flag = true

然后如果 flag == true 就 index++

```cpp
void CVideoPreviewModel::SendPointToPreviewScreen(CPoint& pt, CString oid, long kind)
{
	TreeNodeDropData data;
	data.pt = pt;
	data.oid = oid;
	data.kind = kind;
	Notify(EVT_TREENODE_DRAGDROP_RELEASE, &data);
	return;
}

EVT_TREENODE_DRAGDROP_RELEASE
  
ON_CUEVT_HANDLE(EVT_TREENODE_DRAGDROP_RELEASE,OnEncoderDrop)
  
bool b_areaFlag;

b_areaFlag=false
  
void CPreviewScreenWnd::OnEncoderDrop(IEventData* pData)
{
	if(pData)
	{
		TreeNodeDropData* pEvtData=dynamic_cast<TreeNodeDropData*>(pData);
		if(pEvtData)
		{
			CPoint pt = pEvtData->pt;
			UINT nIndex=GetIndexByPoint(pt);
		
			IVideoPreviewModel* pModel=GetInlPtr<IVideoPreviewModel*>(_T("VideoPreviewModel"));
			if (pModel)
			{
				static int addindex = 0;
				//拖拽通道或转台通道
				if (pEvtData->kind==ENCKIND || pEvtData->kind==TURNTABLEENCKIND)
				{
					//area区域多摄像头打开
					if(b_areaFlag)
					{
						pModel->OpenVideoPreview(pEvtData->oid, nIndex+addindex, true);	
						addindex++;
					}
					else
						pModel->OpenVideoPreview(pEvtData->oid, nIndex, true);			
				}
				//拖拽设备
				else if (pEvtData->kind==ONVIF_DVRKIND||pEvtData->kind==HK_DVRKIND||pEvtData->kind==DH_DVRKIND)
				{
					pModel->OpenVideoPreview(pEvtData->oid);
				}
				else if (pEvtData->kind == AREAKIND)
				{
					b_areaFlag = !b_areaFlag;
					if(!b_areaFlag)
						addindex = 0;
				}
			}
			return;
		}
	}
	return;
}
```



```cpp
LRESULT CPreviewDeviceTree::OnTreeNodeDBClick(HTREEITEM item,TreeNode* pNode)
{
	//OutputDebugString("DoubleClick!\n");
	//AfxMessageBox("db");
	if (pNode)
	{
		MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
		if (pMitObj)
		{
			IVideoPreviewModel* pModel=GetInlPtr<IVideoPreviewModel*>(_T("VideoPreviewModel"));

			if (pModel)
			{
				//双击通道
				if (pMitObj->info.kind==ENCKIND)
				{
					UINT nIndex = pModel->GetSelectItem();
					pModel->OpenVideoPreview(pMitObj->info.oid, nIndex, true);				
				}
				//双击转台通道
				else if (pMitObj->info.kind==TURNTABLEENCKIND)
				{
					UINT nIndex = pModel->GetSelectItem();
					CHAR szPid[MITOIDLEN] = {0};
					TMitObjIdKVPair kv;
					char * p = (char*)(LPCTSTR)(pMitObj->info.oid); 
					char * pIdx = strstr(p,"\\tv=1");
					if(pIdx)
					{
						memcpy(szPid,p,pIdx-p);
					}
					else
					{
						mitGetPid(pMitObj->info.oid, MITOIDLEN, szPid, &kv);
					}
					pModel->OpenVideoPreview(szPid, nIndex, true);	
				}
				//双击设备
				else if (pMitObj->info.kind==ONVIF_DVRKIND||pMitObj->info.kind==HK_DVRKIND||pMitObj->info.kind==DH_DVRKIND)
				{
					std::vector<HTREEITEM> buf;
					GetChildrenItem(item,buf);
					std::vector<HTREEITEM>::iterator its;
					for (its=buf.begin();its!=buf.end();its++)
					{
						TreeNode* pCNode=(TreeNode*)GetItemData(*its);
						MitObject* pCMitObj=dynamic_cast<MitObject*>(pCNode);
						if (pCMitObj)
						{
							if (pCMitObj->info.kind==ENCKIND)
							{
								pModel->OpenVideoPreview(pCMitObj->info.oid);
							}
						}
					}
				}
				else if(pMitObj->info.kind==AREAKIND)
				{
					//AfxMessageBox("area");
					int nIndex=pModel->GetSelectItem();
					std::vector<HTREEITEM> buf;
					GetChildrenItem(item,buf);
					std::vector<HTREEITEM>::iterator its;
					for (its=buf.begin();its!=buf.end();its++)
					{
						//AfxMessageBox("area1");
						std::vector<HTREEITEM> child_buf;
						GetChildrenItem(*its,child_buf);
						std::vector<HTREEITEM>::iterator child_its;
						for (child_its=child_buf.begin();child_its!=child_buf.end();child_its++)
						{
							//AfxMessageBox("area2");
							TreeNode* pCNode=(TreeNode*)GetItemData(*child_its);
							MitObject* pCMitObj=dynamic_cast<MitObject*>(pCNode);
							if (pCMitObj)
							{
								if (pCMitObj->info.kind==ENCKIND)
								{
									//AfxMessageBox("area3");
									pModel->OpenVideoPreview(pCMitObj->info.oid, nIndex, true);
									nIndex++;
								}
							}
						}
					}	
				}
			}
		}
	}
	return NULL;
}
```

```cpp
void CPreviewDeviceTree::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bDragging)
	{
		VERIFY (m_pDragImage->DragLeave (GetDesktopWindow ()));	
		m_pDragImage->EndDrag ();

		if (m_pDragImage)
		{
			delete m_pDragImage;
			m_pDragImage=NULL;
		}
		VERIFY (::ReleaseCapture ());
		m_bDragging = FALSE;

		HCURSOR cur=::LoadCursor(NULL,MAKEINTRESOURCE(IDC_ARROW));
		SetCursor(cur);

		CPoint pt (point);
		ClientToScreen (&pt);
		//
		TreeNode* pNode=(TreeNode*)(GetItemData(m_hDragItem));//选中的节点
		if (OnTreeNodeDragDrop(m_hDragItem,pNode))
		{
			IVideoPreviewModel* pModel=GetInlPtr<IVideoPreviewModel*>(_T("VideoPreviewModel"));
			if (pModel)
			{
				MitObject* pMitObj=dynamic_cast<MitObject*>(pNode);
				if (pMitObj)
				{
					CString oid;
					long kind = pMitObj->info.kind;
					//区域分组areakind

					//拖拽通道
					if (pMitObj->info.kind==ENCKIND)
					{
						oid = pMitObj->info.oid;
						pModel->SendPointToPreviewScreen(pt, oid, kind);				
					}
					//拖拽转台通道
					else if (pMitObj->info.kind==TURNTABLEENCKIND)
					{
						UINT nIndex = pModel->GetSelectItem();
						CHAR szPid[MITOIDLEN] = {0};
						TMitObjIdKVPair kv;
						char * p = (char*)(LPCTSTR)(pMitObj->info.oid); 
						char * pIdx = strstr(p,"\\tv=1");
						if(pIdx)
						{
							memcpy(szPid,p,pIdx-p);
						}
						else
						{
							mitGetPid(pMitObj->info.oid, MITOIDLEN, szPid, &kv);
						}
						oid = szPid;
						pModel->SendPointToPreviewScreen(pt, oid, kind);	
					}
					//拖拽设备
					else if (pMitObj->info.kind==ONVIF_DVRKIND||pMitObj->info.kind==HK_DVRKIND||pMitObj->info.kind==DH_DVRKIND)
					{
						std::vector<HTREEITEM> buf;
						GetChildrenItem(m_hDragItem,buf);
						std::vector<HTREEITEM>::iterator its;
						for (its=buf.begin();its!=buf.end();its++)
						{
							TreeNode* pCNode=(TreeNode*)GetItemData(*its);
							MitObject* pCMitObj=dynamic_cast<MitObject*>(pCNode);
							if (pCMitObj)
							{
								if (pCMitObj->info.kind==ENCKIND)
								{
									oid = pMitObj->info.oid;
									pModel->SendPointToPreviewScreen(pt, oid, kind);	
								}
							}
						}
					}
					else if(pMitObj->info.kind==AREAKIND)
					{
						pModel->SendPointToPreviewScreen(pt, pMitObj->info.oid, pMitObj->info.kind);
						std::vector<HTREEITEM> buf;
						GetChildrenItem(m_hDragItem,buf);
						std::vector<HTREEITEM>::iterator its;
						for (its=buf.begin();its!=buf.end();its++)
						{
							std::vector<HTREEITEM> child_buf;
							GetChildrenItem(*its,child_buf);
							std::vector<HTREEITEM>::iterator child_its;
							for (child_its=child_buf.begin();child_its!=child_buf.end();child_its++)
							{
								TreeNode* pCNode=(TreeNode*)GetItemData(*child_its);
								MitObject* pCMitObj=dynamic_cast<MitObject*>(pCNode);
								if (pCMitObj)
								{
									//AfxMessageBox(pCMitObj->info.name);
									if (pCMitObj->info.kind==ENCKIND)
									{
										oid = pCMitObj->info.oid;
										pModel->SendPointToPreviewScreen(pt, oid, pCMitObj->info.kind);
									}
								}
							}
						}
					}
				}			
			}
		}
	}
	SelectDropTarget(NULL);
	Invalidate();
	CTreeCtrl::OnLButtonUp(nFlags, point);
}

```



更改文件: PreviewDeviceTree.cpp PreviewScreenWnd.h PreviewScreenWnd.cpp



262145 pt











